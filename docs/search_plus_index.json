{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Welcome to MyHearthStone.The name of the book comes from a Game called MyHearthStone.That means lots of glorious cards in your pocket. This book covers algorithm,data structure,java,linux,math,network,programming language,spring framework,database and the needs and dmp business. All of my knowledge writes here! "},"java/":{"url":"java/","title":"1.Java","keywords":"","body":""},"java/elementary/":{"url":"java/elementary/","title":"1.0 Java Elememtary","keywords":"","body":""},"java/jvm/":{"url":"java/jvm/","title":"1.1 Java virtual machine","keywords":"","body":""},"java/specification/":{"url":"java/specification/","title":"1.2 Java Specification","keywords":"","body":""},"java/specification/JMS/":{"url":"java/specification/JMS/","title":"1.2.1 JMS","keywords":"","body":""},"java/design pattern/":{"url":"java/design pattern/","title":"1.3 Design Pattern","keywords":"","body":""},"java/microservice/":{"url":"java/microservice/","title":"1.4 Java Microservice","keywords":"","body":""},"java/microservice/mq/":{"url":"java/microservice/mq/","title":"1.4.1 mq","keywords":"","body":"Introduction 目录： 简介 使用场景 特点 MQ相关名词 Active MQ使用例子 总结 参考 QA 1.简介 JMS及java message service，即java消息服务。JMS是一套面向消息中间件的API接口规范，用于在不同的程序中异步的发送消息。JMS本身与语言无关，绝大多数的消息中间件厂商都提供了对JMS的支持。给予JMS实现的消息中间件，也叫做JMS Provider 消息服务，传递的载体是消息(message)。在JMS中，消息主体可以分为几个类型：简单文本(TextMessage)、可序列化的对象(ObjectMessage)、属性集合(MapMessage)、字节流(BytesMessage)、原始值流(StreamMessage) 消息队列是一种FIFO的数据结构。如下图: 图1 消息队列 如图，其中Provider是生产者，负责提供消息；Consumer是消费者，负责消费消息。Message是消息体，放在队列当中。 2.使用场景 应用解耦 以电商系统为例，应用中有订单系统，库存系统，物流系统，支付系统。用户创建订单后，如果耦合调用库存系统，物流系统，支付系统(具体手段：在代码中直接调用相关系统的API)。任何一个子系统出现故障都会造成订单失败。 图2 应用解耦 当引入消息队列的方式后，订单系统把订单相关信息转变成消息放在消息队列。即使支付系统，物流系统，库存系统当中出现故障也不会导致订单系统出错。当出现故障的系统恢复后，可以继续消费这个订单消息。 流量消峰 还是以电商系统为例，订单系统的吞吐量是10000订单/s。但是在流量高峰时期，用户数远远大于这个值，就会造成某些用户不能下单的情况。引入消息队列后，不能立即处理的订单可以先放到消息队列，这样下单后的界面可以变成“订单处理中”，而不是界面一直“未响应”的状态，这样的用户体验就好得多。 消息发布 消息发布有两种模式，分别是p2p(point to point)和发布-订阅模式(publish-subscribe)。其中p2p模式指的是有一个生产者和消费者，生产者将消息放到queue中，消息者进行消费。发布订阅模式针对topic，订阅方订阅topic。 图3 消息模式 对于Publish-Subscribe模式来说，当生产者进行消息发布时，凡是订阅了这个topic的都会消费这个消息 异步消息 有些服务间调用是异步的，例如A调用B，但是B的响应时间过长，这时候同步操作是不合适的。可以通过异步的方式，当B执行完成发送消息告诉A执行完毕。 3.特点 应用解耦 流量消峰 消息发布 异步消息 4.MQ相关名词 Provider： ​ 消息生产者，负责发送消息到目的地(Destination)。应用接口为MessageProducer。 Consumer: ​ 消息接收者，负责从目的地(Destination)接收消息。应用接口为MessageConsumer Destination: ​ 目的地。JMS Provider进行维护，用于对消息对象进行管理。MessageProducer需要指定Destination才能发送消息，MessageConsumer需要指定Destination才能接收消息 Message: ​ 消息体，一般有TextMessage、ObjectMessage、BytesMessage。 ConnectionFactory: ​ 连接工厂。用于创建连接 Connection: ​ 连接。用于和ActiveMQ建立连接，一般由ConnectionFactory创建 Session: ​ 会话。Session是操作消息的接口。可以通过session创建生产者、消费者、消息等信息。Session支持事务特征，当需要批处理（发送或者接收）消息的时候，可以将这些操作放到一个事务中进行。 Queue和Topic: ​ Queue - 队列目的地。Topic - 主题目的地。都是Destination的子接口。 　Queue：一般队列中的一条消息，默认的只能被一个消费者消费。消费完成即删除。 　Topic：消息会发送给所有订阅的消费者。消息不会持久化，也即如果发消息时不存在订阅关系，则消息直接丢弃。 下图是JMS规范中 API Interface: 图4 JMS Classic API Interface 图5 Simplied API Interface 图5 JMS Queue API 图7 Publish-Subscribe API 从上面的API图感悟： 对于这种C-S模式的应用来说，都是由 ConnectionFactory -获取-> Connection-获取-> Session->Session做具体的操作 具体的例子有：JMS，数据库连接池(datasource) 图8 C-S模式下的交互 首先创建连接，然后获取连接中的会话。在会话中完成具体的和服务端的交互。 5.active mq使用例子 5.1 下载安装activeMQ 5.2 将activeMQ的bin目录添加到path路径下 5.3 activemq start 启动mq ​ 注意：activemq使用tcp://ip:61616 传递消息 ​ activemq页面管理 ip:8161/admin 用户名/密码 amdin/admin Producer package com.cfang.mq.simpleCase; import javax.jms.Connection; import javax.jms.ConnectionFactory; import javax.jms.Destination; import javax.jms.JMSException; import javax.jms.Message; import javax.jms.MessageProducer; import javax.jms.Session; import org.apache.activemq.ActiveMQConnectionFactory; public class SimpleProducer { public static void main(String[] args) { SimpleProducer simpleProducer = new SimpleProducer(); simpleProducer.sendMsg(\"我有一只小毛驴\"); } public void sendMsg(String msg) { ConnectionFactory factory = null; //连接工厂 Connection connection = null; //连接对象 Session session = null; //session会话 Destination destination = null; //目的地 MessageProducer producer = null; //生产者 Message message = null; //消息 try { //创建连接工厂，前两个参数是做安全认证使用，本例中尚未开启。 factory = new ActiveMQConnectionFactory(null, null, \"tcp://172.31.31.160:61616\"); //通过工厂创建连接对象 connection = factory.createConnection(); //启动连接。生产者通常来说不是必须显式启动的，在发送消息的时候，会检测是否启动，未启动的话会先进行启动操作。 connection.start(); /** * 根据连接对象信息，创建session会话信息。 * 第一个参数为是否开启事务特性。 * false - 不开启事务。使用比较多的配置。 * true - 开启事务。如果开启事务，这第二个参数默认无效了，建议还是写成Session.SESSION_TRANSACTED * 第二个参数表示消息确认机制。 * AUTO_ACKNOWLEDGE - 自动消息确认。消息消费者接受处理消息后，自动发送确认信息 * CLIENT_ACKNOWLEDGE - 手动确认。消息消费者在接受处理消息后，必须手动发起确认ack信息 * DUPS_OK_ACKNOWLEDGE - 有副本的手动确认机制。 */ session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //创建目的地，参数是目的地名称，也即队列名。 destination = session.createQueue(\"tp_simple_queue\"); //创建消息生产者，参数为目的地，也可以不指定，在发送消息的时候再指定 producer = session.createProducer(destination); //创建消息 message = session.createTextMessage(msg); //发送到ActiveMQ指定的目的地中 producer.send(message); System.out.println(\"=====send msg ok!=====\"); } catch (Exception e) { e.printStackTrace(); } finally { // 回收资源 if(producer != null){ // 回收消息发送者 try { producer.close(); } catch (JMSException e) { e.printStackTrace(); } } if(session != null){ // 回收会话对象 try { session.close(); } catch (JMSException e) { e.printStackTrace(); } } if(connection != null){ // 回收连接对象 try { connection.close(); } catch (JMSException e) { e.printStackTrace(); } } } } } Consumer package com.cfang.mq.simpleCase; import javax.jms.Connection; import javax.jms.ConnectionFactory; import javax.jms.Destination; import javax.jms.JMSException; import javax.jms.Message; import javax.jms.MessageConsumer; import javax.jms.Session; import javax.jms.TextMessage; import org.apache.activemq.ActiveMQConnectionFactory; public class SimpleConsumer { public static void main(String[] args) { SimpleConsumer simpleConsumer = new SimpleConsumer(); System.out.println(\"=====receive msg: \" + simpleConsumer.receiveMsg()); } public String receiveMsg() { String result = \"\"; ConnectionFactory factory = null; //连接工厂 Connection connection = null; //连接对象 Session session = null; //session会话 Destination destination = null; //目的地 MessageConsumer consumer = null; //生产者 Message message = null; //消息 try { factory = new ActiveMQConnectionFactory(null, null, \"tcp://172.31.31.160:61616\"); connection = factory.createConnection(); //不同于生产者存在自动启动机制，消息的消费者必须显式的手动启动连接 connection.start(); session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //创建目的地，参数是目的地名称，也即队列名。 destination = session.createQueue(\"tp_simple_queue\"); //创建消费者，参数为目的地，也可以不指定，在发送消息的时候再指定 consumer = session.createConsumer(destination); //接收一条消息 message = consumer.receive(); //手动确认 // message.acknowledge(); result = ((TextMessage)message).getText(); } catch (Exception e) { e.printStackTrace(); } finally { // 回收资源 if(consumer != null){ // 回收消息发送者 try { consumer.close(); } catch (JMSException e) { e.printStackTrace(); } } if(session != null){ // 回收会话对象 try { session.close(); } catch (JMSException e) { e.printStackTrace(); } } if(connection != null){ // 回收连接对象 try { connection.close(); } catch (JMSException e) { e.printStackTrace(); } } } return result; } } 6.总结 1.了解消息队列的概念 2.了解JMS规范中规定的接口说明 3.了解ActiveMQ使用方式 4.了解消息队列的使用场景 7.参考 https://www.jianshu.com/p/9a0e9ffa17dd https://blog.csdn.net/qq_33404395/article/details/80590113 https://www.cnblogs.com/eric-fang/p/11314191.html https://www.cnblogs.com/williamjie/p/9481780.html 8.QA a.如何保证消息不被重复消费 ​ 消费者在发送消息的时候，消息消费完毕之后，会发送一个确认消息给消息队列，消息队列就知道消息被消费了，就会将该消息从消息队列中删除（类似TCP握手时的确认)。只是不同的消息队列发送的确认信息形式不同,例如RabbitMQ是发送一个ACK确认消息，RocketMQ是返回一个CONSUME_SUCCESS成功标志，kafka实际上有个offset的概念，简单说一下(如果还不懂，出门找一个kafka入门到精通教程),就是每一个消息都有一个offset，kafka消费过消息后，需要提交offset，让消息队列知道自己已经消费过了。那造成重复消费的原因?，就是因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将该消息分发给其他的消费者。 如何解决?这个问题针对业务场景来答分以下几点   (1)比如，你拿到这个消息做数据库的insert操作。那就容易了，给这个消息做一个唯一主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。   (2)再比如，你拿到这个消息做redis的set的操作，那就容易了，不用解决，因为你无论set几次结果都是一样的，set操作本来就算幂等操作。   (3)如果上面两种情况还不行，上大招。准备一个第三方介质,来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将以K-V形式写入redis。那消费者开始消费前，先去redis中查询有没消费记录即可。 采用确认模式的消息队列： 图9 采用确认模式的消息队列 b.如何保证消息的顺序性 分析:其实并非所有的公司都有这种业务需求，但是还是对这个问题要有所复习。 回答:针对这个问题，通过某种算法，将需要保持先后顺序的消息放到同一个消息队列中(kafka中就是partition,rabbitMq中就是queue)。然后只用一个消费者去消费该队列。 有的人会问:那如果为了吞吐量，有多个消费者去消费怎么办？ 这个问题，没有固定回答的套路。比如我们有一个微博的操作，发微博、写评论、删除微博，这三个异步操作。如果是这样一个业务场景，那只要重试就行。比如你一个消费者先执行了写评论的操作，但是这时候，微博都还没发，写评论一定是失败的，等一段时间。等另一个消费者，先执行写评论的操作后，再执行，就可以成功。 总之，针对这个问题，我的观点是保证入队有序就行，出队以后的顺序交给消费者自己去保证，没有固定套路。 c.如何保证消费的可靠性传输 分析：在使用消息队列的过程中，应该做到消息不能多消费，也不能少消费。每种MQ都要从三个角度来分析:生产者弄丢数据、消息队列弄丢数据、消费者弄丢数据 c.1 生产者丢数据 从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息。 transaction机制就是说，发送消息前，开启事物(channel.txSelect())，然后发送消息，如果发送过程中出现什么异常，事物就会回滚(channel.txRollback())，如果发送成功则提交事物(channel.txCommit())。 然而缺点就是吞吐量下降了。因此，按照博主的经验，生产上用confirm模式的居多。一旦channel进入confirm模式，所有在该信道上面发布的消息都将会被指派一个唯一的ID(从1开始)，一旦消息被投递到所有匹配的队列之后，rabbitMQ就会发送一个Ack给生产者(包含消息的唯一ID)，这就使得生产者知道消息已经正确到达目的队列了.如果rabiitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作 图10 事务执行过程 开启事务（Begin Transaction），如果事务在执行过程中出错则回滚（Rollback），否则提交（Commit） public void transactionalMethod(Session session){ try{ //开启事务 session.beginTransaction(); //处理业务逻辑，例如：SQL语句 session.doMethod(); //如果上面方法执行成功，则走到下面这一步：这个很关键 //提交事务:说明上面的业务肯定成功执行了 session.commit(); }catch(Exception e){ //如果处理业务逻辑出错 //进行业务回滚 session.rollBack(); }finally{ //关闭session session.close(); } } //上面的思想很关键，基本就是Spring @Transactional注解的处理方式. c.2 消息队列丢数据 处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发 这个思想和上面的是一样的，都是先做可能出错的操作，如果操作安全/成功 完成，再发送确认信号 c.3 消费者丢数据 这种情况一般是自动提交了offset，然后你处理程序过程中挂了。kafka以为你处理好了。再强调一次offset是干嘛的 offset：指的是kafka的topic中的每个消费组消费的下标。简单的来说就是一条消息对应一个offset下标，每次消费数据的时候如果提交offset，那么下次消费就会从提交的offset加一那里开始消费。 比如一个topic中有100条数据，我消费了50条并且提交了，那么此时的kafka服务端记录提交的offset就是49(offset从0开始)，那么下次消费的时候offset就从50开始消费。 解决方案也很简单，改成手动提交即可。 意思：就是先做了确认操作，然后消费消息。这样的危险时处理消息时候报错。改为先消费消息，成功后手动发送确认 "},"java/tomcatxjetty/":{"url":"java/tomcatxjetty/","title":"1.5 Tomcat & Jetty","keywords":"","body":""},"java/asmxjavassit/":{"url":"java/asmxjavassit/","title":"1.6 Asm & Javassist","keywords":"","body":""},"java/jndi/":{"url":"java/jndi/","title":"1.7 Jndi","keywords":"","body":"JNDI - Java Naming and Directory Interface 目录： 简介 实例 总结 参考 1.简介 JNDI(Java Naming and Directory Interface，Java命名和目录接口)是一组在Java应用中访问命名和目录服务的API。命名服务将名称和对象联系起来，使得我们可以用名称访问对象。 JNDI类似于JDBC一样,提供了一系列编程接口,用来规范命名服务中对象的创建和管理,通过JNDI可以实现对象的创建与托管,和对象的使用过程完全解耦. 比如:在application的底层创建对象,并将对象bind到特定的context中,对象的创建过程或者\"查找\"方式只有此底层模块支持,外部程序不可见.对于对象的使用者(调用者)只能通过JNDI的方式获取对象,对象使用者无法直接创建对象等. ​ 在JMS，JMail,JDBC,EJB等技术中，就大量应用的这种技术。JNDI可访问的现有的目录及服务有：DNS、XNam 、Novell目录服务、LDAP(Lightweight Directory Access Protocol 轻型目录访问协议)、 CORBA对象服务、文件系统、Windows XP/2000/NT/Me/9x的注册表、RMI、DSML v1&v2、NIS。 ​ jndi诞生的理由似乎很简单。随着分布式应用的发展，远程访问对象访问成为常用的方法。虽然说通过Socket等编程手段仍然可实现远程通信，但按照模式的理论来说，仍是有其局限性的。RMI技术，RMI-IIOP技术的产生，使远程对象的查找成为了技术焦点。JNDI技术就应运而生。JNDI技术产生后，就可方便的查找远程或是本地对象。 ​ 就是不要在程序中直接new资源。而是把资源的配置放到程序之外(配置文件)，通过JNDI来管理资源对象。 图1 JNDI架构 ​ 如图，从下往上看。JNDI SPI厂商都有对应的LDAP，DNS，NIS等的实现。这些技术几乎都涉及到资源的使用。这些资源对象统一由Naming Manager进行管理。程序只需要使用JNDI API通过资源名称获取相应的资源即可。 2.实例 使用JDBC连接数据库： Connection conn=null; try { Class.forName(\"com.mysql.jdbc.Driver\", true, Thread.currentThread().getContextClassLoader()); conn=DriverManager.getConnection(\"jdbc:mysql://MyDBServer?user=xxx&password=xxx\"); ...... conn.close(); } catch(Exception e) { e.printStackTrace(); } finally { if(conn!=null) { try { conn.close(); } catch(SQLException e) {} } 使用JNDI做法： 配置数据源:(配置数据源的位置根据具体的web服务器决定) MySqlDS jdbc:mysql://localhost:3306/lw com.mysql.jdbc.Driver root rootpassword org.jboss.resource.adapter.jdbc.vendor.MySQLExceptionSorter mySQL 使用JNDI连接数据库： Connection conn=null; try { Context ctx = new InitialContext(); Object datasourceRef = ctx.lookup(\"java:MySqlDS\"); //引用数据源 DataSource ds = (Datasource) datasourceRef; conn = ds.getConnection(); ...... c.close(); } catch(Exception e) { e.printStackTrace(); } finally { if(conn!=null) { try { conn.close(); } catch(SQLException e) {} } 这样的好处就是，不需要在程序中管理资源的配置的具体信息。如果遇到更改资源配置的场景，只需要更改配置，而不需要更改代码。 辨析：context.lookup(\"java:comp/env/XXX\")和context.lookup(\"XXX\")的区别。 Answer：context.loopup(\"java:comp/env/XXX\")只能用在J2EE环境，也就是Web项目。而context.lookup(\"XXX\")可以用在任何环境，只需要\"XXX\"是一个JNDI资源名字即可。 3.总结 1.了解JNDI 2.了解JNDI的架构 3.了解JNDI思想：将由JNDI管理的资源以：名字-资源对象 的方式管理起来，程序通过名字来检索对象。 4.了解JNDI例子 4.参考 https://blog.csdn.net/wn084/article/details/80729230 https://www.iteye.com/blog/shift-alt-ctrl-1971329 http://www.atguigu.com/jsfx/1399.html https://yq.aliyun.com/articles/533367?spm=a2c4e.11153940.0.0.278265e2Z66a2E "},"spring framework/":{"url":"spring framework/","title":"2.Spring Framework","keywords":"","body":""},"spring framework/spring-core/":{"url":"spring framework/spring-core/","title":"2.1 Spring-Core","keywords":"","body":""},"spring framework/spring-mvc/":{"url":"spring framework/spring-mvc/","title":"2.2 Spring-Mvc","keywords":"","body":""},"spring framework/spring-mvc/spring-mvc-request-annotation/":{"url":"spring framework/spring-mvc/spring-mvc-request-annotation/","title":"2.2.1 SpringMVC注解","keywords":"","body":"SpringMVC注解-Annotated Controllers 目录： 简介 SpringMVC常用注解 handler method arguments 总结 参考资料 1.简介 SpringMVC provides an annotation-based programming model where @Component and @RestContrller components use annotations to express request mappings, request input, exception handling,and more.Annotated controllers have flexible method signatures and do not have to extend 2.springmvc常用注解 @RequestParam @RequestParam annotations to bind servlet request parameters (query paramters , form data) to a method argument in a controller.（key-value. form data(表单数据)也是以key-value传输的） type conversion is automatically applied if the target method parameter type is not String. when an @RequestParam annotation declared as a Map or MultiValueMap argument, the map is populated with all request parameters. 注意：@RequestParam适用于，请求Content-type:text/plan; 或者application/x-www.form-urlencoded。对于form表单来说，post提交会将key-value放在body体中。而get提交会将key-value放在url后面 @RequestParam注解用来处理Content-Type: 为 application/x-www-form-urlencoded编码的内容。提交方式为get或post。（Http协议中，form的enctype属性为编码方式，常用有两种：application/x-www-form-urlencoded和multipart/form-data，默认为application/x-www-form-urlencoded）； @RequestParam注解实质是将Request.getParameter() 中的Key-Value参数Map利用Spring的转化机制ConversionService配置，转化成参数接收对象或字段， get方式中queryString的值，和post方式中body data的值都会被Servlet接受到并转化到Request.getParameter()参数集中，所以@RequestParam可以获取的到； 该注解有三个属性： value、required、defaultValue； value用来指定要传入值的id名称，required用来指示参数是否必录，defaultValue表示参数不传时候的默认值。 @Controller @RequestMapping(value=\"/user\",method={HttpRequestMethod.POST,HttpRequestMethod.GET}) public class UserController{ /** * 获取单个请求参数 */ @RequsetMapping(value=\"/getInfo\") @ResponseBody public User getUser(@RequestParam(\"name\")String name){ // service return user; } } @Controller @RequestMapping(value=\"/user\",method={HttpRequestMethod.POST,HttpRequestMethod.GET}) public class UserController{ /** * 获取全部请求参数 */ @RequsetMapping(value=\"/getInfo\") @ResponseBody public User getUser(@RequestParam Map params){ // service return user; } } @Controller @RequestMapping(value=\"/user\",method={HttpRequestMethod.POST,HttpRequestMethod.GET}) public class UserController{ /** * POST * content-type:application/x-www-urlencoded * form表单单数与User字段属性对应 */ @RequsetMapping(value=\"/addUser\",method={RequestMethod.POST}) @ResponseBody public User addUser(User user){ // service return user; } } @RequestBody you can use the @RequestBody annotation to have the request body read and deserialized info an Object through HttpMessageConverter. @Controller @RequestMapping(value=\"/user\",method={HttpRequestMethod.POST,HttpRequestMethod.GET}) public class UserController{ /** * 请求参数转为对象 */ @RequsetMapping(value=\"/add\") @ResponseBody public HttpEntity addUser(@RequestBody User user){ return HttpEntity.success(); } /** * 前端请求参数为单个: 名称id */ @RequsetMapping(value=\"/add\") @ResponseBody public HttpEntity addUser(@RequestBody Map param){ String id = param.get(\"id\"); return HttpEntity.success(); } } @RequestBody常用来处理Content-type:application/json格式的请求。 需要在pom.xml和springmvc-servlet.xml中配置 pom.xml com.fasterxml.jackson.core jackson-core ${jackson.version} com.fasterxml.jackson.core jackson-databind ${jackson.version} springmvc-servlet.xml @RequestHeader 获取Http请求头部信息 if the target method parameter is not String , type conversion is automatically applied. @GetMapping(\"/demo\") public void handle(@RequestHeader(\"Accept-Encoding\")String encoding, @RequestHeader(\"keep-Alive\")Long keepAlive){ //... } when an @RequestHeader annotation is used on a Map , MultiValueMap,or HttpHeaders,the map is populated with all header values. Built-in support is avaliable for converting a comma-sperated string into an array or collection of strings or other types known to the type conversion system.For example, a method parameter annotated with @RequestHeader(\"Accept\") can be of type String but also String[] or List @GetMapping(\"/demo\") public void handle(@RequestHeader(\"Accept\")String[] accpet){ //... } @CookieValue 获取cookie值 @GetMapping(\"/demo\") public void handle(@CookieValue(\"JSESSIONID\")String cookie){ //... } 3.handler method arguments 4.总结 5.参考资料 https://www.cnblogs.com/haha12/p/10336363.html https://blog.csdn.net/summerSunStart/article/details/78676781 https://blog.csdn.net/outsanding/article/details/80871769 https://blog.csdn.net/lch_2016/article/details/81022646 "},"spring framework/spring-mvc/spring-mvc-interceptor/":{"url":"spring framework/spring-mvc/spring-mvc-interceptor/","title":"2.2.2 SpringMVC拦截器","keywords":"","body":"SpringMVC拦截器 目录： 简介 HandlerInterceptor和WebRequestHandler接口 拦截器处理逻辑 多个拦截器处理流程 Spring和SpringBoot配置拦截器方式 参考资料 1.简介 SpringMVC拦截器(Interceptor)用于实现对每一个请求前后进行相关的业务处理。SpringMVC中的拦截器是通过HandlerInterceptor来实现的。在Spring中定义拦截器方式。 实现Spring的HandlerInterceptor接口 继承实现HandlerInteceptor接口的类，比如Spring已经提供了实现了HandlerInterceptor接口的抽象类HandlerInterceptorAdapter 实现Spring的WebRequestInterceptor接口 继承实现了WebRequestInterceptor接口的类 实现了拦截器后，可以通过重写WebMvcConfigure的addInterceptors方法注册拦截器 2.HandlerInterceptor和WebRequestInteceptor接口 HandlerInteceptor /* * Copyright 2002-2019 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * https://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.springframework.web.servlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.springframework.lang.Nullable; import org.springframework.web.method.HandlerMethod; /** * Workflow interface that allows for customized handler execution chains. * Applications can register any number of existing or custom interceptors * for certain groups of handlers, to add common preprocessing behavior * without needing to modify each handler implementation. * * A HandlerInterceptor gets called before the appropriate HandlerAdapter * triggers the execution of the handler itself. This mechanism can be used * for a large field of preprocessing aspects, e.g. for authorization checks, * or common handler behavior like locale or theme changes. Its main purpose * is to allow for factoring out repetitive handler code. * * In an asynchronous processing scenario, the handler may be executed in a * separate thread while the main thread exits without rendering or invoking the * {@code postHandle} and {@code afterCompletion} callbacks. When concurrent * handler execution completes, the request is dispatched back in order to * proceed with rendering the model and all methods of this contract are invoked * again. For further options and details see * {@code org.springframework.web.servlet.AsyncHandlerInterceptor} * * Typically an interceptor chain is defined per HandlerMapping bean, * sharing its granularity. To be able to apply a certain interceptor chain * to a group of handlers, one needs to map the desired handlers via one * HandlerMapping bean. The interceptors themselves are defined as beans * in the application context, referenced by the mapping bean definition * via its \"interceptors\" property (in XML: a &lt;list&gt; of &lt;ref&gt;). * * HandlerInterceptor is basically similar to a Servlet Filter, but in * contrast to the latter it just allows custom pre-processing with the option * of prohibiting the execution of the handler itself, and custom post-processing. * Filters are more powerful, for example they allow for exchanging the request * and response objects that are handed down the chain. Note that a filter * gets configured in web.xml, a HandlerInterceptor in the application context. * * As a basic guideline, fine-grained handler-related preprocessing tasks are * candidates for HandlerInterceptor implementations, especially factored-out * common handler code and authorization checks. On the other hand, a Filter * is well-suited for request content and view content handling, like multipart * forms and GZIP compression. This typically shows when one needs to map the * filter to certain content types (e.g. images), or to all requests. * * @author Juergen Hoeller * @since 20.06.2003 * @see HandlerExecutionChain#getInterceptors * @see org.springframework.web.servlet.handler.HandlerInterceptorAdapter * @see org.springframework.web.servlet.handler.AbstractHandlerMapping#setInterceptors * @see org.springframework.web.servlet.handler.UserRoleAuthorizationInterceptor * @see org.springframework.web.servlet.i18n.LocaleChangeInterceptor * @see org.springframework.web.servlet.theme.ThemeChangeInterceptor * @see javax.servlet.Filter */ public interface HandlerInterceptor { /** * Intercept the execution of a handler. Called after HandlerMapping determined * an appropriate handler object, but before HandlerAdapter invokes the handler. * DispatcherServlet processes a handler in an execution chain, consisting * of any number of interceptors, with the handler itself at the end. * With this method, each interceptor can decide to abort the execution chain, * typically sending an HTTP error or writing a custom response. * Note: special considerations apply for asynchronous * request processing. For more details see * {@link org.springframework.web.servlet.AsyncHandlerInterceptor}. * The default implementation returns {@code true}. * @param request current HTTP request * @param response current HTTP response * @param handler chosen handler to execute, for type and/or instance evaluation * @return {@code true} if the execution chain should proceed with the * next interceptor or the handler itself. Else, DispatcherServlet assumes * that this interceptor has already dealt with the response itself. * @throws Exception in case of errors */ default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { return true; } /** * Intercept the execution of a handler. Called after HandlerAdapter actually * invoked the handler, but before the DispatcherServlet renders the view. * Can expose additional model objects to the view via the given ModelAndView. * DispatcherServlet processes a handler in an execution chain, consisting * of any number of interceptors, with the handler itself at the end. * With this method, each interceptor can post-process an execution, * getting applied in inverse order of the execution chain. * Note: special considerations apply for asynchronous * request processing. For more details see * {@link org.springframework.web.servlet.AsyncHandlerInterceptor}. * The default implementation is empty. * @param request current HTTP request * @param response current HTTP response * @param handler handler (or {@link HandlerMethod}) that started asynchronous * execution, for type and/or instance examination * @param modelAndView the {@code ModelAndView} that the handler returned * (can also be {@code null}) * @throws Exception in case of errors */ default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception { } /** * Callback after completion of request processing, that is, after rendering * the view. Will be called on any outcome of handler execution, thus allows * for proper resource cleanup. * Note: Will only be called if this interceptor's {@code preHandle} * method has successfully completed and returned {@code true}! * As with the {@code postHandle} method, the method will be invoked on each * interceptor in the chain in reverse order, so the first interceptor will be * the last to be invoked. * Note: special considerations apply for asynchronous * request processing. For more details see * {@link org.springframework.web.servlet.AsyncHandlerInterceptor}. * The default implementation is empty. * @param request current HTTP request * @param response current HTTP response * @param handler handler (or {@link HandlerMethod}) that started asynchronous * execution, for type and/or instance examination * @param ex any exception thrown on handler execution, if any; this does not * include exceptions that have been handled through an exception resolver * @throws Exception in case of errors */ default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception { } } WebRequestInterceptor /* * Copyright 2002-2016 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * https://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.springframework.web.context.request; import org.springframework.lang.Nullable; import org.springframework.ui.ModelMap; /** * Interface for general web request interception. Allows for being applied * to Servlet request by building on the {@link WebRequest} abstraction. * * This interface assumes MVC-style request processing: A handler gets executed, * exposes a set of model objects, then a view gets rendered based on that model. * Alternatively, a handler may also process the request completely, with no * view to be rendered. * * In an async processing scenario, the handler may be executed in a separate * thread while the main thread exits without rendering or invoking the * {@code postHandle} and {@code afterCompletion} callbacks. When concurrent * handler execution completes, the request is dispatched back in order to * proceed with rendering the model and all methods of this contract are invoked * again. For further options and comments see * {@code org.springframework.web.context.request.async.AsyncWebRequestInterceptor} * * This interface is deliberately minimalistic to keep the dependencies of * generic request interceptors as minimal as feasible. * * @author Juergen Hoeller * @since 2.0 * @see ServletWebRequest * @see org.springframework.web.servlet.DispatcherServlet * @see org.springframework.web.servlet.handler.AbstractHandlerMapping#setInterceptors * @see org.springframework.web.servlet.HandlerInterceptor */ public interface WebRequestInterceptor { /** * Intercept the execution of a request handler before its invocation. * Allows for preparing context resources (such as a Hibernate Session) * and expose them as request attributes or as thread-local objects. * @param request the current web request * @throws Exception in case of errors */ void preHandle(WebRequest request) throws Exception; /** * Intercept the execution of a request handler after its successful * invocation, right before view rendering (if any). * Allows for modifying context resources after successful handler * execution (for example, flushing a Hibernate Session). * @param request the current web request * @param model the map of model objects that will be exposed to the view * (may be {@code null}). Can be used to analyze the exposed model * and/or to add further model attributes, if desired. * @throws Exception in case of errors */ void postHandle(WebRequest request, @Nullable ModelMap model) throws Exception; /** * Callback after completion of request processing, that is, after rendering * the view. Will be called on any outcome of handler execution, thus allows * for proper resource cleanup. * Note: Will only be called if this interceptor's {@code preHandle} * method has successfully completed! * @param request the current web request * @param ex exception thrown on handler execution, if any * @throws Exception in case of errors */ void afterCompletion(WebRequest request, @Nullable Exception ex) throws Exception; } 方法区别： HandlerInterceptor WebRequestInterceptor boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) void preHandle(WebRequest request) void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) void postHandle(WebRequest request, @Nullable ModelMap model) void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) void afterCompletion(WebRequest request, @Nullable Exception ex) 可以看到preHandler方法的区别。HandlerInterceptor返回boolean，用来判断请求是否可以向下执行。通过注释可以发现HandlerInteceptor和WebRequestInterceptor的preHandler的区别。前者重在执行handler之间的逻辑判断；后者重在对资源的初始化上面。 3.拦截器处理逻辑 首先我们看一下SpringMVC的处理流程。 图1 SpringMVC处理流程 ​ 图片来自头条@黄小斜 SpringMVC具体的执行过程如下： 1.请求通过DispatcherServlet进行路由 2.这个类使用HandlerMapping找到对应的Controller/或者叫Handler preHandle 3.然后再通过HandlerAdapter确定由Controller里面哪个具体的方法执行 4.由上面Controller里面具体方法返回ModelAndView。 postHandle 5.然后由ViewResolver决定选择哪个View/视图 6.然后使用Model渲染这个上面返回的视图 afterCompletion 7.最后返回Response对象 boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) Intercept the execution of a handler. Called after HandlerMapping determined an appropriate handler object, but before HandlerAdapter invokes the handler. DispatcherServlet processes a handler in an execution chain, consisting of any number of interceptors, with the handler itself at the end. With this method, each interceptor can decide to abort the execution chain, typically sending an HTTP error or writing a custom response. Note: special considerations apply for asynchronous request processing. For more details see AsyncHandlerInterceptor. 可以看出preHandler是在HandlerMapping确定了Handler对象之后，调用Handler对象之前，所以在preHandle中可以访问到Handler对象 void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,@Nullable ModelAndView modelAndView) Intercept the execution of a handler. Called after HandlerAdapter actually invoked the handler, but before the DispatcherServlet renders the view. Can expose additional model objects to the view via the given ModelAndView postHandle在调用了Handler之后，渲染视图之前，所以能够访问到ModelAndView对象。 void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,@Nullable Exception ex) Callback after completion of request processing, that is, after rendering the view. Will be called on any outcome of handler execution, thus allows for proper resource cleanup. Note: Will only be called if this interceptor's preHandle method has successfully completed and returned true! As with the postHandle method, the method will be invoked on each interceptor in the chain in reverse order, so the first interceptor will be the last to be invoked. 渲染视图之后，并且只有preHandler返回true才会调用。 上面的结合springMVC处理流程看。 4.多个拦截器处理流程 当存在多个拦截器时，拦截器的处理流程如下： preHandle #1 -> preHandle #2 -> preHandle -> #3 -> Handler postHandle #3 afterCompletion #3 当存在多个拦截器时，preHandle方法按照拦截器的注册顺序 顺序执行，postHandle方法则按照拦截器的注册顺序 逆序执行，afterCompletion方法则按照拦截器的注册顺序 逆序执行。 5.Spring和SpringBoot配置拦截器方式 SpringBoot配置拦截器 1.定义拦截器 图2 定义拦截器 2.注册拦截器 图3 注册拦截器 Spring拦截器注册方式 6.参考资料 https://www.jianshu.com/p/25ea148edbc1 https://www.toutiao.com/a6808139254972023300/ https://www.cnblogs.com/juanzila/p/11276067.html https://www.cnblogs.com/jing99/p/11147152.html https://blog.csdn.net/qq924862077/article/details/53524507 https://www.jianshu.com/p/1e8d088c2be9 https://blog.csdn.net/qq_36918149/article/details/93405589 "},"spring framework/spring-mvc/spring-global-exception/":{"url":"spring framework/spring-mvc/spring-global-exception/","title":"2.2.3 Spring全局统一异常处理","keywords":"","body":"Spring全局统一异常处理 目录： 简介 注册异常处理器 参考资料 1.简介 在实际的web工程开发中，会出现各种类型的异常，通常的做法是使用try-catch将可能出现异常的代码进行处理。然而这样的缺点是，会出现大量的样版式代码，异常处理逻辑和正常业务逻辑相耦合，开发人员不仅要写业务代码，还要考虑业务中可能出现的异常。Spring统一异常处理能解决上面的问题，将正常业务逻辑和异常业务逻辑解耦。其处理方式如下： 图1 Spring异常处理 如图所示，异常类型#1/#2/#3都是业务层可能产生的异常，这些异常经过Spring统一异常处理返回给前端相应的状态码或者Model对象。具体的异常处理逻辑在Spring统一异常处理层做，而不是耦合在业务层。 2.注册异常处理器 2.1 Controller 图2 controller层 2.2 ExceptionHandler 图2 ExceptionHandler ExceptionHandler处理NullPointerException，并且向前端返回状态码 注意：@ControllerAdvice , @ExceptionHandler 3.参考资料 https://www.toutiao.com/a6471246543285387790/ https://www.toutiao.com/a6597726289598087688/ https://www.toutiao.com/a6568045618189566467/ "},"spring framework/spring-mvc/spring-mvc-async-servlet/":{"url":"spring framework/spring-mvc/spring-mvc-async-servlet/","title":"2.2.4 Spring异步处理Servlet","keywords":"","body":"Spring异步处理Servlet 目录: 简介 原理 例子 [参考资料][参考资料] 1.简介 2.原理 3.例子 4.参考资料 https://www.oschina.net/question/1414315_2286431?sort=time https://www.jianshu.com/p/f9e2255ffec2 https://blog.csdn.net/he90227/article/details/52262163 （推荐） https://www.iteye.com/blog/elim-2426566 （推荐） https://www.iteye.com/blog/elim-2426566 https://www.cnblogs.com/zemliu/p/3556615.html "},"spring framework/spring-test/":{"url":"spring framework/spring-test/","title":"2.3 Spring-Test","keywords":"","body":""},"spring framework/spring-test/spring-web-mock-test/":{"url":"spring framework/spring-test/spring-web-mock-test/","title":"2.3.1 Spring-mvc-mock","keywords":"","body":"Spring-mvc mock Test 目录: 简介 maven依赖 测试用例 QA 1.简介 Spring Mock测试框架允许用代码的方式进行http请求，从而测试Spring mvc的controller，service，dao的整个代码。与Postman不一样的是，Postman进行http请求时需要启动服务器。 mock测试指的是在测试环境下生成生产环境下的对象，从而进行测试。例如：在Tomcat服务器中，HttpServletRequest对象是服务器生成，需要启动服务器才能获取这个对象；然而在mock环境下可以mock所需要的HttpServletRequest对象 2.maven依赖 junit junit 4.1.13 org.springframework spring-test 4.1.3.RELEASE 3.测试用例 @Runwith(SpringJunit4ClassRunner.class) // 只有WebMvc项目使用这个注解 @WebApplicationConfiguration // 配置事务管理器，默认回滚事务，保证测试数据库数据完整性 @TransactionConfiguration(transanctionManager=\"txManager\",defaultRollBack=true) @Transactional // spring配置文件位置 @ContextConfiguration(locations={\"classpath:spring.xml\",\"classpath=springmvc.xml\"}) public class SpringMvcTest{ protected MockMvc mock; @Autowired private WebApplicationContext wac; // 设置WebApplicationContext对象 @Before public void setMockMvc(){ mock = MockMvcBuilder.webAppContextSetup(wac).build(); } /** * 测试目标： * 测试数据： * 测试结果： * * */ @Test public void postTest(){ // 构造post请求 mock.perform(MockMvcRequestBuilders.post(\"url\") .contentType(\"application/json\") .content(\"json\")).andDo(print(()); } } 4.QA 注意： 1.项目中配置了拦截器，用于拦截某个特定的用户的登录信息。 这种情况下要在测试代码中首先(@Before)配置好拦截器要拦截的信息，直至请求能够到达Controller层 "},"spring framework/spring-boot/":{"url":"spring framework/spring-boot/","title":"2.4 Spring-Boot","keywords":"","body":" "},"spring framework/spring-boot/spring-boot项目配置/":{"url":"spring framework/spring-boot/spring-boot项目配置/","title":"2.4.1 Spring-boot项目配置","keywords":"","body":"Spring项目配置 目录： 简介 Spring-boot项目结构 Spring-boot配置 特点 总结 参考 1.简介 Spring Boot makes it easy to create stand-alone,production-grade Spring based Applications that you can \"just run\". we take and opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring boot applicaitons need Spring Configuration. 我们在使用Spring Boot时只需要配置相应的Spring Boot就可以用所有的Spring组件，简单的说，spring boot就是整合了很多优秀的框架，不用我们自己手动的去写一堆xml配置然后进行配置。 2.Spring-boot项目结构 图1 Spring-Boot项目结构 图2 Spring Configuration和Component Spring-Boot/Spring项目的两个主要配置就是，配置类/x-config.xml，属性文件。这是Spring项目的重点。 配置类/x-config.xml提供Spring项目运行需要的对象 配置@SpringBootApplication注解相当于配置了@Configuration ,@EnableAutoConfiguration ,@ComponentScan Indicates a configuration class that declares one or more @Bean methods and also triggers auto-configuration and component scanning .This is a convenience annotation that is equivalent to declaring @Configuration, @EnableAutoConfiguration and @ComponentScan. 3.Spring-boot配置 1.maven配置 org.springframework.boot spring-boot-starter-web org.springframework.boot spring-boot-starter-logging org.springframework.boot spring-boot-starter-tomcat org.springframework.boot spring-boot-starter-test test org.springframework.boot spring-boot-starter-log4j2 1.5.8.RELEASE org.springframework.boot spring-boot-starter-tomcat provided org.mybatis.spring.boot mybatis-spring-boot-starter 2.0.0 2.SpringBootDemoApplication配置 SpringBoot项目作为一个annotation-driven的项目，配置大都是依赖注解 @SpringBootApplication @EnableAsync @EnableTransactionaManageMent @EnableAspectJAutoProxy(proxyTargetClass = true, exposeProxy = true) @PropertySources(value = { @PropertySource(value = {\"classpath:config/common.properties\"}, ignoreResourceNotFound = true, encoding = \"utf-8\")}) @Import(SpringConfiguration.class) public class SpringBootDemoApplication { public static void main(String[] args) { SpringApplication.run(SpringBootDemoApplication.class, args); } } 3.SpringBoot项目集成MyBatis 引入依赖 org.mybatis mybatis 3.5.4 org.mybatis.spring.boot mybatis-spring-boot-starter 2.0.0 项目结构 图3 SpringBoot继承Mybatis app.properties里面添加mybatis.mapper-locations=classpath:mapper/*.xml。MyBatisMapper接口上面使用@Mapper注解 4.特点 Create stand-alone Spring applications 快速创建独立运行的Spring项目 Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files) 内嵌Tomcat，应用无需打成WAR包 Provide opinionated 'starter' dependencies to simplify your build configuration starters自动依赖简化配置 Automatically configure Spring and 3rd party libraries whenever possible 自动配置Spring和第三方库 Provide production-ready features such as metrics, health checks, and externalized configuration 准生产环境的运行时应用监控 Absolutely no code generation and no requirement for XML configuration 无代码生成和XML配置 5.总结 学会创建Spring-Boot项目 了解Spring-Boot项目结构 了解Spring-Boot配置 6.参考 https://baijiahao.baidu.com/s?id=1623648034778672046&wfr=spider&for=pc https://baijiahao.baidu.com/s?id=1638998808858231030&wfr=spider&for=pc https://blog.csdn.net/qq_31142237/article/details/89326765 https://blog.csdn.net/qq_19167629/article/details/90899232 "},"spring framework/spring-data/":{"url":"spring framework/spring-data/","title":"2.5 Spring-Data","keywords":"","body":""},"spring framework/spring-cloud/":{"url":"spring framework/spring-cloud/","title":"2.6 Spring-Cloud","keywords":"","body":""},"spring framework/spring-rest/":{"url":"spring framework/spring-rest/","title":"2.7 Spring-Rest","keywords":"","body":""},"spring framework/spring-util/":{"url":"spring framework/spring-util/","title":"2.8 Spring-Util","keywords":"","body":""},"spring framework/spring-util/spring-cron/":{"url":"spring framework/spring-util/spring-cron/","title":"2.8.1 Spring定时任务和Cron表达式","keywords":"","body":"Spring定时任务和Cron表达式 目录： 简介 Cron表达式 Spring定时任务配置 QA 参考资料 1.简介 Spring定时任务框架根据cron表达式对任务进行定时调度。本节主要内容是Cron表达式和Spring定时任务的配置 2.Cron表达式 Cron表达式是用来配置Spring定时任务执行时间的时间串，由5个空格分隔成的6个域构成，格式如下 {秒/seconde} {分/minutes} {时/hour} {日/dayofmonth} {月/month} {周/dayofweek} 每一个域含义解释： 1)秒：表示在指定的秒数触发定时任务，范围0-59。例如，\"*\"表示任何秒都触发，\"0,3\"表示0秒和3秒触发。 2)分：表示在指定的分钟触发定时任务，范围0-59。例如，\"0-3\"表示0分钟到3分钟每分钟都触发，\"0/2\"表示只有偶数分钟触发。 3)时：表示在指定的小时触发定时任务，范围0-23。例如，\"3-15/2\"表示上午3点到下午3点每隔2个小时触发。 4)日：表示在指定的日期触发定时任务，范围1-31(可以写0，但不会生效)。例如，\"1\"表示1号触发，\"5,15\"表示5号和15号触发。需要注意的是，日期可以写0，不会报错但也不会生效。 5)月：表示在指定的月份触发定时任务，范围1-12。例如，\"1-4,12\"表示1月到4月以及12月触发。 6)周：表示在指定的星期触发定时任务，范围0-7(0和7都表示周日)。例如，\"?\"表示一周都触发，\"6,7\"表示周六日触发。 注意，1月到12月可以用对应的英文缩写JAN-DEC代替，周日到周六可以用对应的英文缩写SUN-SAT代替。但是，周日的缩写SUN只会被替换为0，因此在cron表达式的周域，我们可以写6-7，却不能写SAT-SUN。 特殊符号： （1) ：表示匹配该域的任意值。假如在Minutes域使用, 即表示每分钟都会触发事件。 （2）?：只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 ?, 其中最后一位只能用？，而不能使用\\，如果使用*表示不管星期几都会触发，实际上并不是这样。 （3）- ：表示范围。例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次 （4）/ ：表示起始时间开始触发，然后每隔固定时间触发一次。例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次. （5）, ：表示列出枚举值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。 例子： （1）0 0 2 1 * ? * 表示在每月的1日的凌晨2点调整任务 （2）0 15 10 ? * MON-FRI 表示周一到周五每天上午10:15执行作业 （3）0 15 10 ? 6L 2002-2006 表示2002-2006年的每个月的最后一个星期五上午10:15执行作 （4）0 0 10,14,16 * * ? 每天上午10点，下午2点，4点 （5）0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时 （6）0 0 12 ? * WED 表示每个星期三中午12点 （7）0 0 12 * * ? 每天中午12点触发 （8）0 15 10 ? * * 每天上午10:15触发 （9）0 15 10 * * ? 每天上午10:15触发 （10）0 15 10 * * ? 每天上午10:15触发 （11）0 15 10 * * ? 2005 2005年的每天上午10:15触发 （12）0 * 14 * * ? 在每天下午2点到下午2:59期间的每1分钟触发 （13）0 0/5 14 * * ? 在每天下午2点到下午2:55期间的每5分钟触发 （14）0 0/5 14,18 * * ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 （15）0 0-5 14 * * ? 在每天下午2点到下午2:05期间的每1分钟触发 （16）0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发 （17）0 15 10 ? * MON-FRI 周一至周五的上午10:15触发 总结： ​ 1.注意cron特殊符号的用法 ​ 2.注意cron表达式“每天”的写法，0 15 10 ? 或 0 15 0 ? 3.如果指定日期，dayofweek要用? ，例如： 0 15 10 10 * ? ，即每月10号上午10点15分执行 3.Spring定时任务配置 3.1 Springboot配置 1.启用@EnableScheduling注解 图1 启用@EnableScheduling 其中@EnableScheduling可以在配置类@Compnent也可以在Springboot启动类SpringApplicaitonUtil @EnableScheduling This enables detection of @Scheduled annotations on any Spring-managed bean in the container. 2.创建任务类，执行任务使用 @Scheduled注解 例子： method #1: package com.myco.tasks; public class MyTask{ @Scheduled(fixedRate=1000) public void work(){ // task execution logic } } the following configuration would ensure that MyTask.work() is called once every 1000 ms: @Configuration @EnableScheduling public class AppConfig { @Bean public MyTask task() { return new MyTask(); } } method #2: use ComponentScan: @Configuration @EnableScheduling @ComponentScan(basePackages=\"com.myco.tasks\") public class AppConfig { } method #3: Methods annotated with @Scheduled may even be declared directly within @Configuration classes: @Configuration @EnableScheduling public class AppConfig { @Scheduled(fixedRate=1000) public void work() { // task execution logic } } 3.配置执行器(TaskScheduler) By default, will be searching for an associated scheduler definition: either a unique org.springframework.scheduling.TaskScheduler bean in the context, or a TaskScheduler bean named \"taskScheduler\" otherwise; the same lookup will also be performed for a java.util.concurrent.ScheduledExecutorService bean. If neither of the two is resolvable, a local single-threaded default scheduler will be created and used within the registrar. 默认情况下Spring会搜索org.springframework.scheduling.TaskScheduler类型的bean或者名称为taskScheduler的bean，同样也会搜索java.util.concurrent.ScheduledExecutorService类型的bean；如果都没有搜索到，spring会创建一个single-thread scheduler 通过实现SchedulerConfigurer配置执行器 @Configuration @EnableScheduling public class AppConfig implements SchedulingConfigurer { @Override public void configureTasks(ScheduledTaskRegistrar taskRegistrar) { taskRegistrar.setScheduler(taskExecutor()); } @Bean(destroyMethod=\"shutdown\") public Executor taskExecutor() { return Executors.newScheduledThreadPool(100); } } 3.2 Spring xml配置 4.QA 5.参考资料 https://www.cnblogs.com/javahr/p/8318728.html https://www.cnblogs.com/summary-2017/p/8974139.html "},"linux/":{"url":"linux/","title":"3.Linux","keywords":"","body":""},"linux/shell/":{"url":"linux/shell/","title":"3.1 Shell","keywords":"","body":""},"database/":{"url":"database/","title":"4.DataBase","keywords":"","body":""},"database/mysql/":{"url":"database/mysql/","title":"4.1 MySQL","keywords":"","body":""},"database/mysql/sql/":{"url":"database/mysql/sql/","title":"4.1.1 SQL","keywords":"","body":""},"database/mysql/transaction/":{"url":"database/mysql/transaction/","title":"4.1.2 Transaction","keywords":"","body":"MySQL事务特点和四种隔离特性 目录: 简介 事务特性 事务隔离级别 事务提交 参考资料 1.简介 一个事务涉及到大量的CPU操作和IO操作,这些操作被打包成一个执行单元,要么同时完成,要么同时不完成.事务是一组原子性SQL命令或者说一个独立的工作单元,如果数据库引擎能够成功对数据库应用该组的全部SQL语句.那么就执行该组命令.如果其中任何一条语句因为崩溃或者其它原因无法执行,那么该组所有的SQL语句都无法执行. 可以这么理解事务.事务是一组TO DO LIST ,事务的每个操作都是TO DO LIST里面的一个ITEM项. -------TO DO LIST-------- #1.item1 #2.item2 #3.item3 .... -------TO DO LIST END--- 事务的具体执行做法就是,逐个执行ITEM( one by one ).如果其中某个ITEM出错则回滚(rollback). 2.事务特性 原子性 一个事务中的所有操作,要么都完成,要么都不执行.对于一个事务来说,不能只执行其中的一部分. 图1 事务原子性 上图这个圆圈代表事务的原子性,一个不被打破的执行单元. 一致性 数据库总是从一个一致性状态转到另外一个一执行状态. 这个一执行状态怎么解释:银行账户300元(一致性状态),然后进行转出操作20元,那么目前银行帐户280(一致性转台) 隔离性 一个事务所做的修改在事务的最终提交之前,对其它事务是不可见的.多个事务之间的操作相互不影响,每降低一个事务隔离个别都能够提高数据库的并发. 持久性 一旦一个事务提交了,就算服务器崩溃,让要在下次启动的时候自动恢复. 结合事务日志完成: ​ 事务日志写入磁盘的时候是顺序IO,写数据文件的时候是随机IO(数据地址不确定).一旦事务提交了,必须立即执行一个IO操作,确保此事务立即写入磁盘. 事务的状态: ​ 活动(active) -----> 中止(pause/inactive)------> 活动 ------> 失败(failed) -------> 部分提交 -----> 提交 3.事务隔离级别 read uncommited (读未提交事务) read commited (读已提交事务) reputable read(可重复读) serializable(可串行化) 脏读(dirty read): 读取到了其它事务未提交的内容 不可重复读(Nonrepetable read): 在同一个事务中,完全相同的select语句可能看到不一样的结果( so wired -_-!). 造成这样的结果可能原因: ​ (1) 有一个交叉的事务有新的commit,导致了数据的改变 ​ (2) 一个数据库被多个实例操作时,同一事务的其它实例在该实例处理期间可能有新的commit 幻影读(phantom read): 读取某一个范围数据行的时候,另一个事务在该范围内插入了新行,当再一次读区这个范围的数据行时,会发现新的“幻影”行. 我个人称之为“眩晕读(duzzy read)”,因为这个感觉就像眼冒金星一样.第二次看到了新的东西(幻影行) 读未提交事务- read uncommited (1)所有事务都可以看到其它事务未提交的执行结果 -------TMD不乱了套了吗 (2)存在问题: 脏读,不可重复读,幻读 执行顺序: 1.select * from tx ; # 事务1 id num 1 1 2 2 3 3 2.update tx set num=10 where id=1 # 事务2 id num 1 10 2 2 3 3 3.select * from tx; #事务1 id num 1 10 2 2 3 3 可以看到事务1读到了事务2未提交的数据 读已提交事务- read commited (1)一个事务只能看见已提交事务所做的改变 (2)存在不可重复读的问题 执行顺序: 1.select * from tx; #事务1 id num 1 1 2 2 3 3 2.update tx set num=10 where id=1(不提交) #事务2 3.select * from tx; #事务1 id num 1 1 2 2 3 3 因为事务2没有提交,所以事务2做的改变事务1看不见 可重复读 - read repeatable (1)解决不可重复读 (2)问题:幻影读 隔离级别 脏读 不可重复读 幻读 读未提交 y y y 读已提交 x y y 可重复读 x x y 串行化 x x x 4.事务提交 如果没有显式启动事务,数据库会根据autocommit的值,默认每条sql都会自动提交 事务日志 事务要保证ACID完成性必须依靠事务日志跟踪,每一个操作在真正写入数据库之前,先写入到日志文件中.如果要删除一行数据会现在日志文件中将此行标记为删除,但是数据库中的文件并没有发生变化.只有在整个事务提交后,再把整个事务的sql语句批量同步到磁盘上的数据库文件. 5.参考资料 https://www.cnblogs.com/xrq730/p/5087378.html https://www.cnblogs.com/devilwind/p/8058268.html https://www.cnblogs.com/snsdzjlz320/p/5761387.html https://www.cnblogs.com/zl0372/articles/mysql_16.html https://www.cnblogs.com/yxh168/p/9174932.html https://blog.csdn.net/weixin_43639512/article/details/84304672 "},"database/redis/":{"url":"database/redis/","title":"4.2 Redis","keywords":"","body":""},"database/mybatis/":{"url":"database/mybatis/","title":"4.3 MyBatis","keywords":"","body":""},"database/mybatis/mybatis参数绑定/":{"url":"database/mybatis/mybatis参数绑定/","title":"4.3.1 MyBatis参数绑定方式","keywords":"","body":"MyBatis参数绑定方式 目录： 简介 XML参数绑定方式 注解参数绑定方式 总结 参考 1.简介 本文主要记录MyBatis使用XML文件和注解进行参数绑定的两种方式，以及在开发过程中遇到的一些MyBatis语法上面遇见的问题 2.XML参数绑定方式 XML参数绑定方式 public interface UserMapperDAO{ //单参数绑定 User selectOne(@Param(\"id\")Long id); //多参数绑定 User selectTne(@Parm(\"id\")Long id,@Param(\"name\")String name); //传入对象 User selectThree(@Param(\"vo\")UserQueryVo vo) } 参数名称传递 .... select * from User where auto_pk = #{id} select * from User where auto_pk = #{id} and name=#{name} select * from User where auto_pk = #{vo.id} and name= #{vo.name} 索引值传递 Mapper接口方法参数从左到右从0开始 .... select * from User where auto_pk = #{0} select * from User where auto_pk = #{0} and name=#{1} select * from User where auto_pk = #{vo.id} and name= #{vo.name} 3.注解参数绑定方式 public interface UserMapperDAO{ //单参数绑定 @Select(\"select * from User where id=#{id}\") User selectOne(@Param(\"id\")Long id); //多参数绑定 @Select(\"select * from User where id=#{id} and name=#{name}\") User selectTne(@Parm(\"id\")Long id,@Param(\"name\")String name); //传入对象 @Select(\"select * from User where id=#{vo.id} and name=#{vo.name}\") //或者 @SelectProvider(type=UserMapperDAOProvider.calss , method=\"selectThree\") User selectThree(@Param(\"vo\")UserQueryVo vo) // 要继承SqlBuilder public static UserMapperDAOProvider extends SqlBuilder{ /** * 返回值：string 即生成的sql语句 * 参数：mybatis会把接口中的注解-对应的值变成map的形式 */ public String selectThree(Map params){ UserQueryVo vo = (UserQueryVo) params.get(\"vo\"); BEGIN(); SELECT(\"*\"); FROM(\"User\"); //注意：使用vo对象里面的属性时必须用下面的方式 WHERE(\"id=#{vo.id}\"); //WHERE(\"id=\" + vo.getId()) ❌错误写法，实际工程实验中会出错 return SQL(); } } } 4.总结 了解MyBatis配置的两种方式XML，注解 了解MyBatis参数绑定的方式：索引值，对象，注解 在Provider中的动态sql中，如果引用对象的值，不要使用WHERE(\"id=\" + vo.getId())，而是使用WHERE(\"id=#{vo.id}\")的方式。而使用vo.getId()是用来进行java逻辑的判断。 MyBatis动态sql的string类型判空: 5.参考 https://www.cnblogs.com/suhaha/p/11794450.html https://blog.csdn.net/u010159380/article/details/82255461 https://blog.csdn.net/qq_21046965/article/details/84993996 "},"database/mybatis/mybatis迭代/":{"url":"database/mybatis/mybatis迭代/","title":"4.3.2 MyBatis迭代器几种写法","keywords":"","body":"MyBatis迭代器 目录： [简介][1] [MyBatis迭代的几种方式][2] [总结][3] [参考资料][4] 1.简介 MyBatis迭代器用于设置SQL中in的条件。即: select * from User where pk in (...)中in的条件。MyBatis中的迭代器格式如下： \" index=\"index\" open=\"(\" separator=\",\" close=\")\"> #{item} collection : 用于迭代的集合名字 index：集合中的元素 index：迭代时的当前元素位置 open：开始符号 separator : 分隔符 close : 结束符号 2.MyBatis迭代的几种方式 参数：java.util.Collection 集合类型 public List getUserByIds(List id); select * from User where pk in #{item} 参数： 数组类型 public List getUserByIds(String[] id); select * from User where pk in #{item} 参数：多个 这种情况下使用Map,将集合以key-value的格式放到Map中，然后在xml中获取名字即可。实际上MyBatis就是将接口中的参数以名字(@Param(\"\"))和其对应的值放到Map中的，所以可以在xml/SelectProvider从Map中获取参数值从而达到动态SQL。 Map map = Maps.newHashMap(\"ids\",Lists.newArrayList()); public void addUser(Map select * from User where pk in #{item} 3.总结 MyBatis对参数的包装使用Map ，其中key为Mybatis的参数名称，value为参数具体值。 这个思想很重要。 例如： @SelectProvider(type=MyProvider.class,method=\"insertUser\") public void addUser(@Param(\"ids\") List ids, @Param(\"name\")String name, @Param(\"age\") int age); 其中addUser的方法参数会被包装为Map：{\"ids\":[] , \"name的值\": \"\" , \"age\": \"age的值\"}。 在SelectProvider中可以获得参数 public class MyProvider extends SQLBuilder{ public String insertUser(Map params){ BEGIN(); String name =(String) params.get(\"name\"); int age = (int)params.get(\"age\"); // 根据业务逻辑拼装SQL return SQL(); } } 3.参考资料 https://blog.csdn.net/zuihongyan518/article/details/86478222 https://www.cnblogs.com/yy3b2007com/p/10417242.html#autoid-0-0-0 https://www.bbsmax.com/A/QV5ZGEa7dy/ "},"network/":{"url":"network/","title":"5.Network","keywords":"","body":""},"network/http/":{"url":"network/http/","title":"5.1 Http","keywords":"","body":""},"network/tcp/":{"url":"network/tcp/","title":"5.2 TCP","keywords":"","body":""},"data structure/":{"url":"data structure/","title":"6.Data Structure","keywords":"","body":""},"algorithm/":{"url":"algorithm/","title":"7.Algorithm","keywords":"","body":""},"math/":{"url":"math/","title":"8.Math","keywords":"","body":""},"programming language/":{"url":"programming language/","title":"9.Programming Language","keywords":"","body":""}}
{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Welcome to MyHearthStone.The name of the book comes from a Game called MyHearthStone.That means lots of glorious cards in your pocket. This book covers algorithm,data structure,java,linux,math,network,programming language,spring framework,database and the needs and dmp business. All of my knowledge writes here! "},"java/":{"url":"java/","title":"1.Java","keywords":"","body":""},"java/elementary/":{"url":"java/elementary/","title":"1.0 Java Elememtary","keywords":"","body":""},"java/jvm/":{"url":"java/jvm/","title":"1.1 Java virtual machine","keywords":"","body":""},"java/specification/":{"url":"java/specification/","title":"1.2 Java Specification","keywords":"","body":""},"java/specification/JMS/":{"url":"java/specification/JMS/","title":"1.2.1 JMS","keywords":"","body":""},"java/design pattern/":{"url":"java/design pattern/","title":"1.3 Design Pattern","keywords":"","body":""},"java/microservice/":{"url":"java/microservice/","title":"1.4 Java Microservice","keywords":"","body":""},"java/microservice/mq/":{"url":"java/microservice/mq/","title":"1.4.1 mq","keywords":"","body":"Introduction 目录： 简介 使用场景 特点 MQ相关名词 Active MQ使用例子 总结 参考 QA 1.简介 JMS及java message service，即java消息服务。JMS是一套面向消息中间件的API接口规范，用于在不同的程序中异步的发送消息。JMS本身与语言无关，绝大多数的消息中间件厂商都提供了对JMS的支持。给予JMS实现的消息中间件，也叫做JMS Provider 消息服务，传递的载体是消息(message)。在JMS中，消息主体可以分为几个类型：简单文本(TextMessage)、可序列化的对象(ObjectMessage)、属性集合(MapMessage)、字节流(BytesMessage)、原始值流(StreamMessage) 消息队列是一种FIFO的数据结构。如下图: 图1 消息队列 如图，其中Provider是生产者，负责提供消息；Consumer是消费者，负责消费消息。Message是消息体，放在队列当中。 2.使用场景 应用解耦 以电商系统为例，应用中有订单系统，库存系统，物流系统，支付系统。用户创建订单后，如果耦合调用库存系统，物流系统，支付系统(具体手段：在代码中直接调用相关系统的API)。任何一个子系统出现故障都会造成订单失败。 图2 应用解耦 当引入消息队列的方式后，订单系统把订单相关信息转变成消息放在消息队列。即使支付系统，物流系统，库存系统当中出现故障也不会导致订单系统出错。当出现故障的系统恢复后，可以继续消费这个订单消息。 流量消峰 还是以电商系统为例，订单系统的吞吐量是10000订单/s。但是在流量高峰时期，用户数远远大于这个值，就会造成某些用户不能下单的情况。引入消息队列后，不能立即处理的订单可以先放到消息队列，这样下单后的界面可以变成“订单处理中”，而不是界面一直“未响应”的状态，这样的用户体验就好得多。 消息发布 消息发布有两种模式，分别是p2p(point to point)和发布-订阅模式(publish-subscribe)。其中p2p模式指的是有一个生产者和消费者，生产者将消息放到queue中，消息者进行消费。发布订阅模式针对topic，订阅方订阅topic。 图3 消息模式 对于Publish-Subscribe模式来说，当生产者进行消息发布时，凡是订阅了这个topic的都会消费这个消息 异步消息 有些服务间调用是异步的，例如A调用B，但是B的响应时间过长，这时候同步操作是不合适的。可以通过异步的方式，当B执行完成发送消息告诉A执行完毕。 3.特点 应用解耦 流量消峰 消息发布 异步消息 4.MQ相关名词 Provider： ​ 消息生产者，负责发送消息到目的地(Destination)。应用接口为MessageProducer。 Consumer: ​ 消息接收者，负责从目的地(Destination)接收消息。应用接口为MessageConsumer Destination: ​ 目的地。JMS Provider进行维护，用于对消息对象进行管理。MessageProducer需要指定Destination才能发送消息，MessageConsumer需要指定Destination才能接收消息 Message: ​ 消息体，一般有TextMessage、ObjectMessage、BytesMessage。 ConnectionFactory: ​ 连接工厂。用于创建连接 Connection: ​ 连接。用于和ActiveMQ建立连接，一般由ConnectionFactory创建 Session: ​ 会话。Session是操作消息的接口。可以通过session创建生产者、消费者、消息等信息。Session支持事务特征，当需要批处理（发送或者接收）消息的时候，可以将这些操作放到一个事务中进行。 Queue和Topic: ​ Queue - 队列目的地。Topic - 主题目的地。都是Destination的子接口。 　Queue：一般队列中的一条消息，默认的只能被一个消费者消费。消费完成即删除。 　Topic：消息会发送给所有订阅的消费者。消息不会持久化，也即如果发消息时不存在订阅关系，则消息直接丢弃。 下图是JMS规范中 API Interface: 图4 JMS Classic API Interface 图5 Simplied API Interface 图5 JMS Queue API 图7 Publish-Subscribe API 从上面的API图感悟： 对于这种C-S模式的应用来说，都是由 ConnectionFactory -获取-> Connection-获取-> Session->Session做具体的操作 具体的例子有：JMS，数据库连接池(datasource) 图8 C-S模式下的交互 首先创建连接，然后获取连接中的会话。在会话中完成具体的和服务端的交互。 5.active mq使用例子 5.1 下载安装activeMQ 5.2 将activeMQ的bin目录添加到path路径下 5.3 activemq start 启动mq ​ 注意：activemq使用tcp://ip:61616 传递消息 ​ activemq页面管理 ip:8161/admin 用户名/密码 amdin/admin Producer package com.cfang.mq.simpleCase; import javax.jms.Connection; import javax.jms.ConnectionFactory; import javax.jms.Destination; import javax.jms.JMSException; import javax.jms.Message; import javax.jms.MessageProducer; import javax.jms.Session; import org.apache.activemq.ActiveMQConnectionFactory; public class SimpleProducer { public static void main(String[] args) { SimpleProducer simpleProducer = new SimpleProducer(); simpleProducer.sendMsg(\"我有一只小毛驴\"); } public void sendMsg(String msg) { ConnectionFactory factory = null; //连接工厂 Connection connection = null; //连接对象 Session session = null; //session会话 Destination destination = null; //目的地 MessageProducer producer = null; //生产者 Message message = null; //消息 try { //创建连接工厂，前两个参数是做安全认证使用，本例中尚未开启。 factory = new ActiveMQConnectionFactory(null, null, \"tcp://172.31.31.160:61616\"); //通过工厂创建连接对象 connection = factory.createConnection(); //启动连接。生产者通常来说不是必须显式启动的，在发送消息的时候，会检测是否启动，未启动的话会先进行启动操作。 connection.start(); /** * 根据连接对象信息，创建session会话信息。 * 第一个参数为是否开启事务特性。 * false - 不开启事务。使用比较多的配置。 * true - 开启事务。如果开启事务，这第二个参数默认无效了，建议还是写成Session.SESSION_TRANSACTED * 第二个参数表示消息确认机制。 * AUTO_ACKNOWLEDGE - 自动消息确认。消息消费者接受处理消息后，自动发送确认信息 * CLIENT_ACKNOWLEDGE - 手动确认。消息消费者在接受处理消息后，必须手动发起确认ack信息 * DUPS_OK_ACKNOWLEDGE - 有副本的手动确认机制。 */ session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //创建目的地，参数是目的地名称，也即队列名。 destination = session.createQueue(\"tp_simple_queue\"); //创建消息生产者，参数为目的地，也可以不指定，在发送消息的时候再指定 producer = session.createProducer(destination); //创建消息 message = session.createTextMessage(msg); //发送到ActiveMQ指定的目的地中 producer.send(message); System.out.println(\"=====send msg ok!=====\"); } catch (Exception e) { e.printStackTrace(); } finally { // 回收资源 if(producer != null){ // 回收消息发送者 try { producer.close(); } catch (JMSException e) { e.printStackTrace(); } } if(session != null){ // 回收会话对象 try { session.close(); } catch (JMSException e) { e.printStackTrace(); } } if(connection != null){ // 回收连接对象 try { connection.close(); } catch (JMSException e) { e.printStackTrace(); } } } } } Consumer package com.cfang.mq.simpleCase; import javax.jms.Connection; import javax.jms.ConnectionFactory; import javax.jms.Destination; import javax.jms.JMSException; import javax.jms.Message; import javax.jms.MessageConsumer; import javax.jms.Session; import javax.jms.TextMessage; import org.apache.activemq.ActiveMQConnectionFactory; public class SimpleConsumer { public static void main(String[] args) { SimpleConsumer simpleConsumer = new SimpleConsumer(); System.out.println(\"=====receive msg: \" + simpleConsumer.receiveMsg()); } public String receiveMsg() { String result = \"\"; ConnectionFactory factory = null; //连接工厂 Connection connection = null; //连接对象 Session session = null; //session会话 Destination destination = null; //目的地 MessageConsumer consumer = null; //生产者 Message message = null; //消息 try { factory = new ActiveMQConnectionFactory(null, null, \"tcp://172.31.31.160:61616\"); connection = factory.createConnection(); //不同于生产者存在自动启动机制，消息的消费者必须显式的手动启动连接 connection.start(); session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //创建目的地，参数是目的地名称，也即队列名。 destination = session.createQueue(\"tp_simple_queue\"); //创建消费者，参数为目的地，也可以不指定，在发送消息的时候再指定 consumer = session.createConsumer(destination); //接收一条消息 message = consumer.receive(); //手动确认 // message.acknowledge(); result = ((TextMessage)message).getText(); } catch (Exception e) { e.printStackTrace(); } finally { // 回收资源 if(consumer != null){ // 回收消息发送者 try { consumer.close(); } catch (JMSException e) { e.printStackTrace(); } } if(session != null){ // 回收会话对象 try { session.close(); } catch (JMSException e) { e.printStackTrace(); } } if(connection != null){ // 回收连接对象 try { connection.close(); } catch (JMSException e) { e.printStackTrace(); } } } return result; } } 6.总结 1.了解消息队列的概念 2.了解JMS规范中规定的接口说明 3.了解ActiveMQ使用方式 4.了解消息队列的使用场景 7.参考 https://www.jianshu.com/p/9a0e9ffa17dd https://blog.csdn.net/qq_33404395/article/details/80590113 https://www.cnblogs.com/eric-fang/p/11314191.html https://www.cnblogs.com/williamjie/p/9481780.html 8.QA a.如何保证消息不被重复消费 ​ 消费者在发送消息的时候，消息消费完毕之后，会发送一个确认消息给消息队列，消息队列就知道消息被消费了，就会将该消息从消息队列中删除（类似TCP握手时的确认)。只是不同的消息队列发送的确认信息形式不同,例如RabbitMQ是发送一个ACK确认消息，RocketMQ是返回一个CONSUME_SUCCESS成功标志，kafka实际上有个offset的概念，简单说一下(如果还不懂，出门找一个kafka入门到精通教程),就是每一个消息都有一个offset，kafka消费过消息后，需要提交offset，让消息队列知道自己已经消费过了。那造成重复消费的原因?，就是因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将该消息分发给其他的消费者。 如何解决?这个问题针对业务场景来答分以下几点   (1)比如，你拿到这个消息做数据库的insert操作。那就容易了，给这个消息做一个唯一主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。   (2)再比如，你拿到这个消息做redis的set的操作，那就容易了，不用解决，因为你无论set几次结果都是一样的，set操作本来就算幂等操作。   (3)如果上面两种情况还不行，上大招。准备一个第三方介质,来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将以K-V形式写入redis。那消费者开始消费前，先去redis中查询有没消费记录即可。 采用确认模式的消息队列： 图9 采用确认模式的消息队列 b.如何保证消息的顺序性 分析:其实并非所有的公司都有这种业务需求，但是还是对这个问题要有所复习。 回答:针对这个问题，通过某种算法，将需要保持先后顺序的消息放到同一个消息队列中(kafka中就是partition,rabbitMq中就是queue)。然后只用一个消费者去消费该队列。 有的人会问:那如果为了吞吐量，有多个消费者去消费怎么办？ 这个问题，没有固定回答的套路。比如我们有一个微博的操作，发微博、写评论、删除微博，这三个异步操作。如果是这样一个业务场景，那只要重试就行。比如你一个消费者先执行了写评论的操作，但是这时候，微博都还没发，写评论一定是失败的，等一段时间。等另一个消费者，先执行写评论的操作后，再执行，就可以成功。 总之，针对这个问题，我的观点是保证入队有序就行，出队以后的顺序交给消费者自己去保证，没有固定套路。 c.如何保证消费的可靠性传输 分析：在使用消息队列的过程中，应该做到消息不能多消费，也不能少消费。每种MQ都要从三个角度来分析:生产者弄丢数据、消息队列弄丢数据、消费者弄丢数据 c.1 生产者丢数据 从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息。 transaction机制就是说，发送消息前，开启事物(channel.txSelect())，然后发送消息，如果发送过程中出现什么异常，事物就会回滚(channel.txRollback())，如果发送成功则提交事物(channel.txCommit())。 然而缺点就是吞吐量下降了。因此，按照博主的经验，生产上用confirm模式的居多。一旦channel进入confirm模式，所有在该信道上面发布的消息都将会被指派一个唯一的ID(从1开始)，一旦消息被投递到所有匹配的队列之后，rabbitMQ就会发送一个Ack给生产者(包含消息的唯一ID)，这就使得生产者知道消息已经正确到达目的队列了.如果rabiitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作 图10 事务执行过程 开启事务（Begin Transaction），如果事务在执行过程中出错则回滚（Rollback），否则提交（Commit） public void transactionalMethod(Session session){ try{ //开启事务 session.beginTransaction(); //处理业务逻辑，例如：SQL语句 session.doMethod(); //如果上面方法执行成功，则走到下面这一步：这个很关键 //提交事务:说明上面的业务肯定成功执行了 session.commit(); }catch(Exception e){ //如果处理业务逻辑出错 //进行业务回滚 session.rollBack(); }finally{ //关闭session session.close(); } } //上面的思想很关键，基本就是Spring @Transactional注解的处理方式. c.2 消息队列丢数据 处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发 这个思想和上面的是一样的，都是先做可能出错的操作，如果操作安全/成功 完成，再发送确认信号 c.3 消费者丢数据 这种情况一般是自动提交了offset，然后你处理程序过程中挂了。kafka以为你处理好了。再强调一次offset是干嘛的 offset：指的是kafka的topic中的每个消费组消费的下标。简单的来说就是一条消息对应一个offset下标，每次消费数据的时候如果提交offset，那么下次消费就会从提交的offset加一那里开始消费。 比如一个topic中有100条数据，我消费了50条并且提交了，那么此时的kafka服务端记录提交的offset就是49(offset从0开始)，那么下次消费的时候offset就从50开始消费。 解决方案也很简单，改成手动提交即可。 意思：就是先做了确认操作，然后消费消息。这样的危险时处理消息时候报错。改为先消费消息，成功后手动发送确认 "},"java/tomcatxjetty/":{"url":"java/tomcatxjetty/","title":"1.5 Tomcat & Jetty","keywords":"","body":""},"java/asmxjavassit/":{"url":"java/asmxjavassit/","title":"1.6 Asm & Javassist","keywords":"","body":""},"java/jndi/":{"url":"java/jndi/","title":"1.7 Jndi","keywords":"","body":"JNDI - Java Naming and Directory Interface 目录： 简介 实例 总结 参考 1.简介 JNDI(Java Naming and Directory Interface，Java命名和目录接口)是一组在Java应用中访问命名和目录服务的API。命名服务将名称和对象联系起来，使得我们可以用名称访问对象。 JNDI类似于JDBC一样,提供了一系列编程接口,用来规范命名服务中对象的创建和管理,通过JNDI可以实现对象的创建与托管,和对象的使用过程完全解耦. 比如:在application的底层创建对象,并将对象bind到特定的context中,对象的创建过程或者\"查找\"方式只有此底层模块支持,外部程序不可见.对于对象的使用者(调用者)只能通过JNDI的方式获取对象,对象使用者无法直接创建对象等. ​ 在JMS，JMail,JDBC,EJB等技术中，就大量应用的这种技术。JNDI可访问的现有的目录及服务有：DNS、XNam 、Novell目录服务、LDAP(Lightweight Directory Access Protocol 轻型目录访问协议)、 CORBA对象服务、文件系统、Windows XP/2000/NT/Me/9x的注册表、RMI、DSML v1&v2、NIS。 ​ jndi诞生的理由似乎很简单。随着分布式应用的发展，远程访问对象访问成为常用的方法。虽然说通过Socket等编程手段仍然可实现远程通信，但按照模式的理论来说，仍是有其局限性的。RMI技术，RMI-IIOP技术的产生，使远程对象的查找成为了技术焦点。JNDI技术就应运而生。JNDI技术产生后，就可方便的查找远程或是本地对象。 ​ 就是不要在程序中直接new资源。而是把资源的配置放到程序之外(配置文件)，通过JNDI来管理资源对象。 图1 JNDI架构 ​ 如图，从下往上看。JNDI SPI厂商都有对应的LDAP，DNS，NIS等的实现。这些技术几乎都涉及到资源的使用。这些资源对象统一由Naming Manager进行管理。程序只需要使用JNDI API通过资源名称获取相应的资源即可。 2.实例 使用JDBC连接数据库： Connection conn=null; try { Class.forName(\"com.mysql.jdbc.Driver\", true, Thread.currentThread().getContextClassLoader()); conn=DriverManager.getConnection(\"jdbc:mysql://MyDBServer?user=xxx&password=xxx\"); ...... conn.close(); } catch(Exception e) { e.printStackTrace(); } finally { if(conn!=null) { try { conn.close(); } catch(SQLException e) {} } 使用JNDI做法： 配置数据源:(配置数据源的位置根据具体的web服务器决定) MySqlDS jdbc:mysql://localhost:3306/lw com.mysql.jdbc.Driver root rootpassword org.jboss.resource.adapter.jdbc.vendor.MySQLExceptionSorter mySQL 使用JNDI连接数据库： Connection conn=null; try { Context ctx = new InitialContext(); Object datasourceRef = ctx.lookup(\"java:MySqlDS\"); //引用数据源 DataSource ds = (Datasource) datasourceRef; conn = ds.getConnection(); ...... c.close(); } catch(Exception e) { e.printStackTrace(); } finally { if(conn!=null) { try { conn.close(); } catch(SQLException e) {} } 这样的好处就是，不需要在程序中管理资源的配置的具体信息。如果遇到更改资源配置的场景，只需要更改配置，而不需要更改代码。 辨析：context.lookup(\"java:comp/env/XXX\")和context.lookup(\"XXX\")的区别。 Answer：context.loopup(\"java:comp/env/XXX\")只能用在J2EE环境，也就是Web项目。而context.lookup(\"XXX\")可以用在任何环境，只需要\"XXX\"是一个JNDI资源名字即可。 3.总结 1.了解JNDI 2.了解JNDI的架构 3.了解JNDI思想：将由JNDI管理的资源以：名字-资源对象 的方式管理起来，程序通过名字来检索对象。 4.了解JNDI例子 4.参考 https://blog.csdn.net/wn084/article/details/80729230 https://www.iteye.com/blog/shift-alt-ctrl-1971329 http://www.atguigu.com/jsfx/1399.html https://yq.aliyun.com/articles/533367?spm=a2c4e.11153940.0.0.278265e2Z66a2E "},"spring framework/":{"url":"spring framework/","title":"2.Spring Framework","keywords":"","body":""},"spring framework/spring-core/":{"url":"spring framework/spring-core/","title":"2.1 Spring-Core","keywords":"","body":""},"spring framework/spring-mvc/":{"url":"spring framework/spring-mvc/","title":"2.2 Spring-Mvc","keywords":"","body":""},"spring framework/spring-mvc/spring-mvc-request-annotation/":{"url":"spring framework/spring-mvc/spring-mvc-request-annotation/","title":"2.2.1 SpringMVC注解","keywords":"","body":"SpringMVC注解-Annotated Controllers 目录： 简介 SpringMVC常用注解 handler method arguments 总结 参考资料 1.简介 SpringMVC provides an annotation-based programming model where @Component and @RestContrller components use annotations to express request mappings, request input, exception handling,and more.Annotated controllers have flexible method signatures and do not have to extend 2.springmvc常用注解 @RequestParam @RequestParam annotations to bind servlet request parameters (query paramters , form data) to a method argument in a controller.（key-value. form data(表单数据)也是以key-value传输的） type conversion is automatically applied if the target method parameter type is not String. when an @RequestParam annotation declared as a Map or MultiValueMap argument, the map is populated with all request parameters. 注意：@RequestParam适用于，请求Content-type:text/plan; 或者application/x-www.form-urlencoded。对于form表单来说，post提交会将key-value放在body体中。而get提交会将key-value放在url后面 @RequestParam注解用来处理Content-Type: 为 application/x-www-form-urlencoded编码的内容。提交方式为get或post。（Http协议中，form的enctype属性为编码方式，常用有两种：application/x-www-form-urlencoded和multipart/form-data，默认为application/x-www-form-urlencoded）； @RequestParam注解实质是将Request.getParameter() 中的Key-Value参数Map利用Spring的转化机制ConversionService配置，转化成参数接收对象或字段， get方式中queryString的值，和post方式中body data的值都会被Servlet接受到并转化到Request.getParameter()参数集中，所以@RequestParam可以获取的到； 该注解有三个属性： value、required、defaultValue； value用来指定要传入值的id名称，required用来指示参数是否必录，defaultValue表示参数不传时候的默认值。 @Controller @RequestMapping(value=\"/user\",method={HttpRequestMethod.POST,HttpRequestMethod.GET}) public class UserController{ /** * 获取单个请求参数 */ @RequsetMapping(value=\"/getInfo\") @ResponseBody public User getUser(@RequestParam(\"name\")String name){ // service return user; } } @Controller @RequestMapping(value=\"/user\",method={HttpRequestMethod.POST,HttpRequestMethod.GET}) public class UserController{ /** * 获取全部请求参数 */ @RequsetMapping(value=\"/getInfo\") @ResponseBody public User getUser(@RequestParam Map params){ // service return user; } } @RequestBody you can use the @RequestBody annotation to have the request body read and deserialized info an Object through HttpMessageConverter. @Controller @RequestMapping(value=\"/user\",method={HttpRequestMethod.POST,HttpRequestMethod.GET}) public class UserController{ /** * 获取单个请求参数 */ @RequsetMapping(value=\"/add\") @ResponseBody public HttpEntity addUser(@RequestBody User user){ return HttpEntity.success(); } } @RequestBody常用来处理Content-type:application/json格式的请求。 需要在pom.xml和springmvc-servlet.xml中配置 pom.xml com.fasterxml.jackson.core jackson-core ${jackson.version} com.fasterxml.jackson.core jackson-databind ${jackson.version} springmvc-servlet.xml @RequestHeader 获取Http请求头部信息 if the target method parameter is not String , type conversion is automatically applied. @GetMapping(\"/demo\") public void handle(@RequestHeader(\"Accept-Encoding\")String encoding, @RequestHeader(\"keep-Alive\")Long keepAlive){ //... } when an @RequestHeader annotation is used on a Map , MultiValueMap,or HttpHeaders,the map is populated with all header values. Built-in support is avaliable for converting a comma-sperated string into an array or collection of strings or other types known to the type conversion system.For example, a method parameter annotated with @RequestHeader(\"Accept\") can be of type String but also String[] or List @GetMapping(\"/demo\") public void handle(@RequestHeader(\"Accept\")String[] accpet){ //... } @CookieValue 获取cookie值 @GetMapping(\"/demo\") public void handle(@CookieValue(\"JSESSIONID\")String cookie){ //... } 3.handler method arguments 4.总结 5.参考资料 https://www.cnblogs.com/haha12/p/10336363.html https://blog.csdn.net/summerSunStart/article/details/78676781 https://blog.csdn.net/outsanding/article/details/80871769 https://blog.csdn.net/lch_2016/article/details/81022646 "},"spring framework/spring-test/":{"url":"spring framework/spring-test/","title":"2.3 Spring-Test","keywords":"","body":""},"spring framework/spring-test/spring-web-mock-test/":{"url":"spring framework/spring-test/spring-web-mock-test/","title":"2.3.1 Spring-mvc-mock","keywords":"","body":"Spring-mvc mock Test 目录: 简介 maven依赖 测试用例 QA 1.简介 Spring Mock测试框架允许用代码的方式进行http请求，从而测试Spring mvc的controller，service，dao的整个代码。与Postman不一样的是，Postman进行http请求时需要启动服务器。 mock测试指的是在测试环境下生成生产环境下的对象，从而进行测试。例如：在Tomcat服务器中，HttpServletRequest对象是服务器生成，需要启动服务器才能获取这个对象；然而在mock环境下可以mock所需要的HttpServletRequest对象 2.maven依赖 junit junit 4.1.13 org.springframework spring-test 4.1.3.RELEASE 3.测试用例 @Runwith(SpringJunit4ClassRunner.class) // 只有WebMvc项目使用这个注解 @WebApplicationConfiguration // 配置事务管理器，默认回滚事务，保证测试数据库数据完整性 @TransactionConfiguration(transanctionManager=\"txManager\",defaultRollBack=true) @Transactional // spring配置文件位置 @ContextConfiguration(locations={\"classpath:spring.xml\",\"classpath=springmvc.xml\"}) public class SpringMvcTest{ protected MockMvc mock; @Autowired private WebApplicationContext wac; // 设置WebApplicationContext对象 @Before public void setMockMvc(){ mock = MockMvcBuilder.webAppContextSetup(wac).build(); } /** * 测试目标： * 测试数据： * 测试结果： * * */ @Test public void postTest(){ // 构造post请求 mock.perform(MockMvcRequestBuilders.post(\"url\") .contentType(\"application/json\") .content(\"json\")).andDo(print(()); } } 4.QA 注意： 1.项目中配置了拦截器，用于拦截某个特定的用户的登录信息。 这种情况下要在测试代码中首先(@Before)配置好拦截器要拦截的信息，直至请求能够到达Controller层 "},"spring framework/spring-boot/":{"url":"spring framework/spring-boot/","title":"2.4 Spring-Boot","keywords":"","body":" "},"spring framework/spring-boot/spring-boot项目配置/":{"url":"spring framework/spring-boot/spring-boot项目配置/","title":"2.4.1 Spring-boot项目配置","keywords":"","body":"Spring项目配置 目录： 简介 Spring-boot项目结构 Spring-boot配置 特点 总结 参考 1.简介 Spring Boot makes it easy to create stand-alone,production-grade Spring based Applications that you can \"just run\". we take and opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring boot applicaitons need Spring Configuration. 我们在使用Spring Boot时只需要配置相应的Spring Boot就可以用所有的Spring组件，简单的说，spring boot就是整合了很多优秀的框架，不用我们自己手动的去写一堆xml配置然后进行配置。 2.Spring-boot项目结构 图1 Spring-Boot项目结构 图2 Spring Configuration和Component Spring-Boot/Spring项目的两个主要配置就是，配置类/x-config.xml，属性文件。这是Spring项目的重点。 配置类/x-config.xml提供Spring项目运行需要的对象 配置@SpringBootApplication注解相当于配置了@Configuration ,@EnableAutoConfiguration ,@ComponentScan Indicates a configuration class that declares one or more @Bean methods and also triggers auto-configuration and component scanning .This is a convenience annotation that is equivalent to declaring @Configuration, @EnableAutoConfiguration and @ComponentScan. 3.Spring-boot配置 1.maven配置 org.springframework.boot spring-boot-starter-web org.springframework.boot spring-boot-starter-logging org.springframework.boot spring-boot-starter-tomcat org.springframework.boot spring-boot-starter-test test org.springframework.boot spring-boot-starter-log4j2 1.5.8.RELEASE org.springframework.boot spring-boot-starter-tomcat provided org.mybatis.spring.boot mybatis-spring-boot-starter 2.0.0 2.SpringBootDemoApplication配置 SpringBoot项目作为一个annotation-driven的项目，配置大都是依赖注解 @SpringBootApplication @EnableAsync @EnableTransactionaManageMent @EnableAspectJAutoProxy(proxyTargetClass = true, exposeProxy = true) @PropertySources(value = { @PropertySource(value = {\"classpath:config/common.properties\"}, ignoreResourceNotFound = true, encoding = \"utf-8\")}) @Import(SpringConfiguration.class) public class SpringBootDemoApplication { public static void main(String[] args) { SpringApplication.run(SpringBootDemoApplication.class, args); } } 3.SpringBoot项目集成MyBatis 引入依赖 org.mybatis mybatis 3.5.4 org.mybatis.spring.boot mybatis-spring-boot-starter 2.0.0 项目结构 图3 SpringBoot继承Mybatis app.properties里面添加mybatis.mapper-locations=classpath:mapper/*.xml。MyBatisMapper接口上面使用@Mapper注解 4.特点 Create stand-alone Spring applications 快速创建独立运行的Spring项目 Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files) 内嵌Tomcat，应用无需打成WAR包 Provide opinionated 'starter' dependencies to simplify your build configuration starters自动依赖简化配置 Automatically configure Spring and 3rd party libraries whenever possible 自动配置Spring和第三方库 Provide production-ready features such as metrics, health checks, and externalized configuration 准生产环境的运行时应用监控 Absolutely no code generation and no requirement for XML configuration 无代码生成和XML配置 5.总结 学会创建Spring-Boot项目 了解Spring-Boot项目结构 了解Spring-Boot配置 6.参考 https://baijiahao.baidu.com/s?id=1623648034778672046&wfr=spider&for=pc https://baijiahao.baidu.com/s?id=1638998808858231030&wfr=spider&for=pc https://blog.csdn.net/qq_31142237/article/details/89326765 https://blog.csdn.net/qq_19167629/article/details/90899232 "},"spring framework/spring-data/":{"url":"spring framework/spring-data/","title":"2.5 Spring-Data","keywords":"","body":""},"spring framework/spring-cloud/":{"url":"spring framework/spring-cloud/","title":"2.6 Spring-Cloud","keywords":"","body":""},"spring framework/spring-rest/":{"url":"spring framework/spring-rest/","title":"2.7 Spring-Rest","keywords":"","body":""},"linux/":{"url":"linux/","title":"3.Linux","keywords":"","body":""},"linux/shell/":{"url":"linux/shell/","title":"3.1 Shell","keywords":"","body":""},"database/":{"url":"database/","title":"4.DataBase","keywords":"","body":""},"database/mysql/":{"url":"database/mysql/","title":"4.1 MySQL","keywords":"","body":""},"database/mysql/sql/":{"url":"database/mysql/sql/","title":"4.1.1 SQL","keywords":"","body":""},"database/mysql/transaction/":{"url":"database/mysql/transaction/","title":"4.1.2 Transaction","keywords":"","body":""},"database/redis/":{"url":"database/redis/","title":"4.2 Redis","keywords":"","body":""},"database/mybatis/":{"url":"database/mybatis/","title":"4.3 MyBatis","keywords":"","body":""},"database/mybatis/mybatis参数绑定/":{"url":"database/mybatis/mybatis参数绑定/","title":"4.3.1 MyBatis参数绑定方式","keywords":"","body":"MyBatis参数绑定方式 目录： 简介 XML参数绑定方式 注解参数绑定方式 总结 参考 1.简介 本文主要记录MyBatis使用XML文件和注解进行参数绑定的两种方式，以及在开发过程中遇到的一些MyBatis语法上面遇见的问题 2.XML参数绑定方式 XML参数绑定方式 public interface UserMapperDAO{ //单参数绑定 User selectOne(@Param(\"id\")Long id); //多参数绑定 User selectTne(@Parm(\"id\")Long id,@Param(\"name\")String name); //传入对象 User selectThree(@Param(\"vo\")UserQueryVo vo) } 参数名称传递 .... select * from User where auto_pk = #{id} select * from User where auto_pk = #{id} and name=#{name} select * from User where auto_pk = #{vo.id} and name= #{vo.name} 索引值传递 Mapper接口方法参数从左到右从0开始 .... select * from User where auto_pk = #{0} select * from User where auto_pk = #{0} and name=#{1} select * from User where auto_pk = #{vo.id} and name= #{vo.name} 3.注解参数绑定方式 public interface UserMapperDAO{ //单参数绑定 @Select(\"select * from User where id=#{id}\") User selectOne(@Param(\"id\")Long id); //多参数绑定 @Select(\"select * from User where id=#{id} and name=#{name}\") User selectTne(@Parm(\"id\")Long id,@Param(\"name\")String name); //传入对象 @Select(\"select * from User where id=#{vo.id} and name=#{vo.name}\") //或者 @SelectProvider(type=UserMapperDAOProvider.calss , method=\"selectThree\") User selectThree(@Param(\"vo\")UserQueryVo vo) // 要继承SqlBuilder public static UserMapperDAOProvider extends SqlBuilder{ /** * 返回值：string 即生成的sql语句 * 参数：mybatis会把接口中的注解-对应的值变成map的形式 */ public String selectThree(Map params){ UserQueryVo vo = (UserQueryVo) params.get(\"vo\"); BEGIN(); SELECT(\"*\"); FROM(\"User\"); //注意：使用vo对象里面的属性时必须用下面的方式 WHERE(\"id=#{vo.id}\"); //WHERE(\"id=\" + vo.getId()) ❌错误写法，实际工程实验中会出错 return SQL(); } } } 4.总结 了解MyBatis配置的两种方式XML，注解 了解MyBatis参数绑定的方式：索引值，对象，注解 在Provider中的动态sql中，如果引用对象的值，不要使用WHERE(\"id=\" + vo.getId())，而是使用WHERE(\"id=#{vo.id}\")的方式。而使用vo.getId()是用来进行java逻辑的判断。 MyBatis动态sql的string类型判空: 5.参考 https://www.cnblogs.com/suhaha/p/11794450.html https://blog.csdn.net/u010159380/article/details/82255461 https://blog.csdn.net/qq_21046965/article/details/84993996 "},"network/":{"url":"network/","title":"5.Network","keywords":"","body":""},"network/http/":{"url":"network/http/","title":"5.1 Http","keywords":"","body":""},"network/tcp/":{"url":"network/tcp/","title":"5.2 TCP","keywords":"","body":""},"data structure/":{"url":"data structure/","title":"6.Data Structure","keywords":"","body":""},"algorithm/":{"url":"algorithm/","title":"7.Algorithm","keywords":"","body":""},"math/":{"url":"math/","title":"8.Math","keywords":"","body":""},"programming language/":{"url":"programming language/","title":"9.Programming Language","keywords":"","body":""}}
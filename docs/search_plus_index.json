{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction Welcome to MyHearthStone.The name of the book comes from a Game called MyHearthStone.That means lots of glorious cards in your pocket. This book covers algorithm,data structure,java,linux,math,network,programming language,spring framework,database and the needs and dmp business. All of my knowledge writes here! Just notebook , don't use for business or making money ! "},"java/":{"url":"java/","title":"1.Java","keywords":"","body":""},"java/elementary/":{"url":"java/elementary/","title":"1.0 Java Elememtary","keywords":"","body":"JAVA基础知识 "},"java/elementary/atomic_unsafe/":{"url":"java/elementary/atomic_unsafe/","title":"1.0.1 AotimicInteger&Unsafe类","keywords":"","body":"AtomicInteger&Unsafe类 目录： [Unsafe类][1] [Unsafe类objectFieldOffset方法][2] [Unsafe类功能][3] [AtomicInteger类][4] [怎么判断一个变量是否线程安全][5] [AtomicInteger类多词getAndDecrement能否保证线程安全][6] [参考资料][7] 1.Unsafe类 "},"java/elementary/executors/":{"url":"java/elementary/executors/","title":"1.0.2 ThreadPoolExecutor","keywords":"","body":"线程池-ThreadPoolExecutor 目录： 简介 如何重用线程 阻塞队列 线程池任务执行流程 线程池状态转换 参考资料 1.简介 java中所有的池化技术都有一个好处，就是通过复用池中的对象，降低系统资源消耗。设想一下如果我们有n多个子任务需要执行，如果我们为每个子任务都创建一个执行线程，而创建线程的过程是需要一定的系统消耗的，最后肯定会拖慢整个系统的处理速度。而通过线程池我们可以做到复用线程，任务有多个，但执行任务的线程可以通过线程池来复用，这样减少了创建线程的开销，系统资源利用率得到了提升。 2.如何重用线程 通过阻塞队列，线程从阻塞队列中获取任务，如果没有任务就阻塞到队列的等待线程列表中。 3.阻塞队列 BlockingQueue提供插入和移除两类方法 图1 BlockQueue提供的插入和移除方法 抛出异常：这时候插入和取出在不能立即被执行的时候就会抛出异常。 特殊值：插入和取出在不能被立即执行的情况下会返回一个特殊的值（true 或者 false） 阻塞：插入和取出操作在不能被立即执行时会阻塞线程，直到条件成熟，被其他线程唤醒 超时：插入和取出操作在不能立即执行的时候会被阻塞一定的时候，如果在指定的时间内没有被执行，那么会返回一个特殊值。 常见的阻塞队列： 图2 常见的阻塞队列 4.线程池任务执行流程 图3 线程池执行流程 ​ 首先判断核心线程池是否满，如果没有满则创建线程执行任务；否则将任务放到任务队列，如果队列满则创建线程，如果线程池满则采用拒绝策略。 拒绝策略有： CallerRunsPolicy 在调用线程中执行任务 AbortPolicy 拒绝任务，并抛出RejectedExecutionExecution异常 DiscardPolicy 忽略任务 DiscardPolicy 移除队列中oldest task 5.线程池状态转换 图4 线程池状态转换 1、RUNNING (1) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行处理。 (02) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处于RUNNING状态，并且线程池中的任务数为0！ private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); 2、 SHUTDOWN (1) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。 (2) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -> SHUTDOWN。 3、STOP (1) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中断正在处理的任务。 (2) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -> STOP。 4、TIDYING (1) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理；可以通过重载terminated()函数来实现。 (2) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也为空时，就会由 SHUTDOWN -> TIDYING。 当线程池在STOP状态下，线程池中执行的任务为空时，就会由STOP -> TIDYING。 5、 TERMINATED (1) 状态说明：线程池彻底终止，就变成TERMINATED状态。 (2) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING -> TERMINATED。 6.参考资料 https://blog.csdn.net/qq_31262175/article/details/90672095 https://baijiahao.baidu.com/s?id=1659873724613844132&wfr=spider&for=pc https://www.jianshu.com/p/32665a52eba1 https://www.jianshu.com/p/b7f7eb2bc778 https://www.cnblogs.com/dwlsxj/p/Thread.html https://www.jianshu.com/p/5847f8759ea6 https://blog.csdn.net/xiaoliuliu2050/article/details/88246816 "},"java/elementary/nio/":{"url":"java/elementary/nio/","title":"1.0.3 NIO","keywords":"","body":"Java NIO 目录： 简介 NIO原理 NIO操作系统层面原理 流程 参考资料 1.简介 Java NIO主要有三部分组成通道(Channel)、缓冲区(Buffer)、选择器(Selector)。传统的IO是面向字节流和字符流的，而NIO基于Channel和Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听同一个通道里面每个的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。 NIO和传统IO（一下简称IO）之间第一个最大的区别是，IO是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。 IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变得可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。 2.NIO原理 ​ Java NIO的原理本质上是IO复用技术。使用一个/几个线程去监视多个IO文件的变化，当其中某个文件可读、可写时，则发出读事件或者写事件，然后将事件传给相应的使用这个文件的工作线程，这个工作线程就可以对这个文件进行读写。如图所示。 图1 Java 阻塞IO ​ 上图是Java经典的阻塞IO，对于每一个文件启用一个线程去进行读写，这样的弊端在于文件读写经常会出现阻塞(数据没有准备好)的情况，此时线程就得处于阻塞阻塞状态，不能执行其他的代码。并且当系统中出现大量IO阻塞的情况时，就会造成大量线程出现阻塞的情况，影响系统的正常运行。 ​ 如果上图的文件是服务器中的连接，那么每一个线程处理一个连接，当线程出现阻塞时，会影响服务器的工作线程数目，导致服务器的服务质量下降 图2 Java NIO ​ 如图所示，Java NIO模型。其中使用一个线程(Selector)去监听Channel中文件状态的变化，当出现读写事件时，将事件传给系统中的工作线程，工作线程就可以直接进行读写即可。这样的优点是，避免了线程阻塞；将工作线程和文件读写状态分离，只有当出现读写事件工作线程才去进行读写，其他时间可以执行别的代码 3. NIO操作系统层面的原理 3.1 网卡接收数据 下图是一个典型的计算机结构图，计算机由CPU、存储器（内存）、网络接口等部件组成。了解epoll本质的第一步，要从硬件的角度看计算机怎样接收网络数据。 图3 计算机结构 下图展示了网卡接收数据的过程。在①阶段，网卡收到网线传来的数据；经过②阶段的硬件电路的传输；最终将数据写入到内存中的某个地址上（③阶段）。这个过程涉及到DMA传输、IO通路选择等硬件有关的知识，但我们只需知道：网卡会把接收到的数据写入内存。 图4 网卡接收数据过程 3.2 如何知道接收了数据 了解epoll本质的第二步，要从CPU的角度来看数据接收。要理解这个问题，要先了解一个概念——中断。 计算机执行程序时，会有优先级的需求。比如，当计算机收到断电信号时（电容可以保存少许电量，供CPU运行很短的一小段时间），它应立即去保存数据，保存数据的程序具有较高的优先级。 一般而言，由硬件产生的信号需要cpu立马做出回应（不然数据可能就丢失），所以它的优先级很高。cpu理应中断掉正在执行的程序，去做出响应；当cpu完成对硬件的响应后，再重新执行用户程序。中断的过程如下图，和函数调用差不多。只不过函数调用是事先定好位置，而中断的位置由“信号”决定。 图5 中断 现在可以回答本节提出的问题了：当网卡把数据写入到内存后，网卡向cpu发出一个中断信号，操作系统便能得知有新数据到来，再通过网卡中断程序去处理数据。 3.3CPU阻塞队列和工作队列 操作系统为了支持多任务，实现了进程调度的功能，会把进程分为“运行”和“等待”等几种状态。运行状态是进程获得cpu使用权，正在执行代码的状态；等待状态是阻塞状态，比如执行recv(Linux接收函数)函数时，程序会从运行状态变为等待状态，接收到数据后又变回运行状态。操作系统会分时执行各个运行状态的进程，由于速度很快，看上去就像是同时执行多个任务。 下图中的计算机中运行着A、B、C三个进程，其中进程A执行着上述基础网络程序，一开始，这3个进程都被操作系统的工作队列所引用，处于运行状态，会分时执行。 图6 工作队列中有A、B和C三个进程 当进程A执行到创建socket的语句时，操作系统会创建一个由文件系统管理的socket对象（如下图）。这个socket对象包含了发送缓冲区、接收缓冲区、等待队列等成员。等待队列是个非常重要的结构，它指向所有需要等待该socket事件的进程。 图7 创建socket 当程序执行到recv时，操作系统会将进程A从工作队列移动到该socket的等待队列中（如下图）。由于工作队列只剩下了进程B和C，依据进程调度，cpu会轮流执行这两个进程的程序，不会执行进程A的程序。所以进程A被阻塞，不会往下执行代码，也不会占用cpu资源。 图8 socket的等待队列 ps：操作系统添加等待队列只是添加了对这个“等待中”进程的引用，以便在接收到数据时获取进程对象、将其唤醒，而非直接将进程管理纳入自己之下。上图为了方便说明，直接将进程挂到等待队列之下。 唤醒进程 当socket接收到数据后，操作系统将该socket等待队列上的进程重新放回到工作队列，该进程变成运行状态（当socket事件触发时，也就是有数据到来，会取下一个进程结构调用其回调，将其挂到工作队列中），继续执行代码。也由于socket的接收缓冲区已经有了数据，recv可以返回接收到的数据。 3.4 内核接收数据全过程 如下图所示，进程在recv阻塞期间，计算机收到了对端传送的数据（步骤①）。数据经由网卡传送到内存（步骤②），然后网卡通过中断信号通知cpu有数据到达，cpu执行中断程序（步骤③）。此处的中断程序主要有两项功能，先将网络数据写入到对应socket的接收缓冲区里面（步骤④），再唤醒进程A（步骤⑤），重新将进程A放入工作队列中。 图9 图内核接收数据全过程 唤醒进程的过程如下图所示。 图10 唤醒进程 4.流程 ​ 了解了操作系统如何接收数据，以及如何挂起和唤醒进程后，再来分析一下NIO的流程 图11 流程 如图当所有的Socket没有事件(OP_ACCEPT(接受数据)，OP_CONNECT(连接) ，OP_WRITE(写) ，OP_READ(读))时，Selector阻塞，直到出现上面上面四种事件之一，终端程序向CPU发出中断，将Selector放到工作队列，将后将相应的事件交给工作线程；将事件交付后，如果没有其他的事件，则Selctor继续阻塞。 5.参考资料 https://blog.csdn.net/songchuwang1868/article/details/89877739 强烈推荐 https://blog.csdn.net/forezp/article/details/88414741 "},"java/elementary/thread/":{"url":"java/elementary/thread/","title":"1.0.4 java线程概念","keywords":"","body":"Java线程 目录： 什么是线程 阻塞非阻塞 线程状态图 ContextClassLoader 参考资料 1.什么是线程 ​ 我个人给出的定义：Thread is A sequence of sorted instructions ，即线程是一个有序指令的序列。例如： ​ s1 CPU必须先执行s1指令(在代码中就是函数)，然后执行s2指令，然后一次执行。假如在执行s2指令时，例如读文件，由于目前文件不可读，所以 线程会阻塞到s2指令，因此引出阻塞和非阻塞的定义。 2.阻塞非阻塞 s1​ 当CPU执行到s2的时候，由于s2指令时间过长，s2后面的指令s3-sn都不会执行，CPU会把当前线程放到等待队列中，此时s2就是阻塞的。 ​ 当然还有一种方法，就是将s2设置为非阻塞，执行到s2指令的时候设置s2返回结果的地址，然后执行后面s3,sn指令，然后采用轮询的方式来询问s2的结果是否ready。 3.线程状态图 图1 线程状态图 当线程执行IO阻塞或者sleep的时候，CPU会把线程放到等待队列中，直到IO执行完成或者sleep结束。而当线程获取对象锁时，如果没有获取都对象得锁，那么线程会到对象的等待队列中，等待被notify进一步获取锁。 4.ContextClassLoader Returns the context ClassLoader for this Thread. The context ClassLoader is provided by the creator of the thread for use by code running in this thread when loading classes and resources. If not {@linkplain #setContextClassLoader set}, the default is the ClassLoader context of the parent Thread. The context ClassLoader of the primordial thread is typically set to the class loader used to load the application. 返回当前线程的contextClassLoader。contextClassLoader由线程创建者提供，供在此线程中运行的代码使用（加载类和资源）。如果没有调用getContextClassLoader，则默认为父线程的contextClassLoader。原始线程的contextClassLoader通常设置为用于加载应用程序的类加载器，也即AppClassLoader。 使用场景：SPI ContextClassLoader是一种与线程相关的类加载器,类似ThreadLocal,每个线程对应一个上下文类加载器.在实际使用时一般都用下面的经典结构: ClassLoader targetClassLoader = null;// 外部参数 ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader(); try { Thread.currentThread().setContextClassLoader(targetClassLoader); // TODO } catch (Exception e) { e.printStackTrace(); } finally { Thread.currentThread().setContextClassLoader(contextClassLoader); } 首先获取当前线程的线程上下文类加载器并保存到方法栈,然后将外部传递的类加载器设置为当前线程上下文类加载器 doSomething则可以利用新设置的类加载器做一些事情 最后在设置当前线程上下文类加载器为老的类加载器 解决的问题：类加载器委托模式下父加载器不能使用子加载器加载的类，如下： AppClassLoader 其中AppClassLoader能使用Bootstrap加载的类，而反过来就不行。而在SPI情境下，服务实现提供商的类都是由AppClassLoader加载进来的，而SPI服务发现类是有Bootstrap类加载的，服务发现类需要使用服务提供商的类，由于Boostrap无法加载有AppClassLoader加载的类，所以就得使用ContextClassLoader来加载。 5.参考资料 https://blog.csdn.net/u013412772/article/details/80851700 https://www.jianshu.com/p/5d7a72427679 https://www.jianshu.com/p/d6ceeaafe9c5 "},"java/elementary/reference/":{"url":"java/elementary/reference/","title":"1.0.4 java应用类型","keywords":"","body":"Java引用类型 目录： 简介 引用类型 应用 参考资料 1.简介 Java Reference即Java对象的引用。在Java中通过引用来操作Java对象。 Object obj = new Object(); 其中，obj指向new Object()，即为一个引用. Java中的垃圾回收(Garbage Collection)机制判断是否回收某个对象的时候,需要根据引用这个概念.通常有两种判断对象是否需要回收的方法: 引用计数法 为每个对象添加一个引用计数器,每当一个引用指向对象时,计数器就加1,当引用失效(obj=null/引用不指向对象)时,计数器就减1,当计数器为0时,则认为这个对象可以被回收. 缺点：对象只有“被引用”，和“未被引用”两种状态，无法满足某些特殊情况下的场景，比如内存紧张时要回收一些对象。而且无法解决对象间互相引用的情况,AB,这种情况我称之为\"对象间的抱团取暖\" 可达性分析 从GC Roots(跟节点)的对象开始像下搜索，如果GC Roots到对象之间没有任何引用链时,则说明对象不可用. 从引用链延伸出了“强引用、软引用、弱引用、虚引用”，这四种引用配合引用链来说明对象的引用情况，从而适用于不同场景下(如内存紧张、GC发生)对象是否需要回收的情况. 2.引用类型 强引用(Strong Reference) 强引用是Java默认支持的一种操作模式，也就是说在引用的处理其间，即使出现有GC，即使内存不足，该引用的数据也不会被回收。 软引用(Soft Reference) 内存不足时才进行GC的空间释放 String s = new String(\"soft reference\"); SoftReference soft = new SoftReference<>(s); s = null; System.gc(); 其中，对象只有在内存不足的情况下，才会被GC回收 应用：软引用中保存的内容如果在内存富裕的时候会继续保留，内存不足会作为第一批的丢弃者进行垃圾空间的释放。可以作为高速缓存组件 弱引用(Weak Reference) GC发生时就回收对象. 虚引用(Phantom Reference) 无法从引用队列中获取对引用对象,只能判断对象是否被加入到了引用队列. String s = new String(\"Phantom Reference\"); ReferenceQueue queue = new ReferenceQueue<>(); PhantomReference pr = new PhantomReference<>(s,queue); str = null; // 断开强引用 pr.isEnqueued(); // true 能够判断对象是否被加入了引用队列 pr.get(); // 无法获得引用对象 引用队列(Reference Queue) Reference queues, to which registered reference objects are appended by the garbage collector after the appropriate reachability changes are detected. 当引用对象的可达性发生变化时，就会被垃圾收集器(garbage collector)添加到引用队列中来 可达性分析 图1 可达性分析 原则： 对象可及性是由引用链上面最弱的引用决定的(木桶理论) 多个引用链的情况下,对象的引用是最强的引用决定的 例如,对于对象5来说由两条引用链. 1 -> 5 (强引用 -> 软引用) 2 -> 6 (强引用 -> 弱引用) 根据上面的原则来判断,对象5的可达性为软引用. 3.应用 4.参考资料 https://www.cnblogs.com/liyutian/p/9690974.html https://blog.csdn.net/qq_19704045/article/details/80646437 "},"java/jvm/":{"url":"java/jvm/","title":"1.1 Java virtual machine","keywords":"","body":""},"java/specification/":{"url":"java/specification/","title":"1.2 Java Specification","keywords":"","body":""},"java/specification/JMS/":{"url":"java/specification/JMS/","title":"1.2.1 JMS","keywords":"","body":""},"java/specification/JMX/":{"url":"java/specification/JMX/","title":"1.2.2 JMX","keywords":"","body":""},"java/specification/JDBC/":{"url":"java/specification/JDBC/","title":"1.2.3 JDBC","keywords":"","body":""},"java/design pattern/":{"url":"java/design pattern/","title":"1.3 Design Pattern","keywords":"","body":""},"java/microservice/":{"url":"java/microservice/","title":"1.4 Java Microservice","keywords":"","body":""},"java/microservice/mq/":{"url":"java/microservice/mq/","title":"1.4.1 mq","keywords":"","body":"Introduction 目录： 简介 使用场景 特点 MQ相关名词 Active MQ使用例子 总结 参考 QA 1.简介 JMS及java message service，即java消息服务。JMS是一套面向消息中间件的API接口规范，用于在不同的程序中异步的发送消息。JMS本身与语言无关，绝大多数的消息中间件厂商都提供了对JMS的支持。给予JMS实现的消息中间件，也叫做JMS Provider 消息服务，传递的载体是消息(message)。在JMS中，消息主体可以分为几个类型：简单文本(TextMessage)、可序列化的对象(ObjectMessage)、属性集合(MapMessage)、字节流(BytesMessage)、原始值流(StreamMessage) 消息队列是一种FIFO的数据结构。如下图: 图1 消息队列 如图，其中Provider是生产者，负责提供消息；Consumer是消费者，负责消费消息。Message是消息体，放在队列当中。 2.使用场景 应用解耦 以电商系统为例，应用中有订单系统，库存系统，物流系统，支付系统。用户创建订单后，如果耦合调用库存系统，物流系统，支付系统(具体手段：在代码中直接调用相关系统的API)。任何一个子系统出现故障都会造成订单失败。 图2 应用解耦 当引入消息队列的方式后，订单系统把订单相关信息转变成消息放在消息队列。即使支付系统，物流系统，库存系统当中出现故障也不会导致订单系统出错。当出现故障的系统恢复后，可以继续消费这个订单消息。 流量消峰 还是以电商系统为例，订单系统的吞吐量是10000订单/s。但是在流量高峰时期，用户数远远大于这个值，就会造成某些用户不能下单的情况。引入消息队列后，不能立即处理的订单可以先放到消息队列，这样下单后的界面可以变成“订单处理中”，而不是界面一直“未响应”的状态，这样的用户体验就好得多。 消息发布 消息发布有两种模式，分别是p2p(point to point)和发布-订阅模式(publish-subscribe)。其中p2p模式指的是有一个生产者和消费者，生产者将消息放到queue中，消息者进行消费。发布订阅模式针对topic，订阅方订阅topic。 图3 消息模式 对于Publish-Subscribe模式来说，当生产者进行消息发布时，凡是订阅了这个topic的都会消费这个消息 异步消息 有些服务间调用是异步的，例如A调用B，但是B的响应时间过长，这时候同步操作是不合适的。可以通过异步的方式，当B执行完成发送消息告诉A执行完毕。 3.特点 应用解耦 流量消峰 消息发布 异步消息 4.MQ相关名词 Provider： ​ 消息生产者，负责发送消息到目的地(Destination)。应用接口为MessageProducer。 Consumer: ​ 消息接收者，负责从目的地(Destination)接收消息。应用接口为MessageConsumer Destination: ​ 目的地。JMS Provider进行维护，用于对消息对象进行管理。MessageProducer需要指定Destination才能发送消息，MessageConsumer需要指定Destination才能接收消息 Message: ​ 消息体，一般有TextMessage、ObjectMessage、BytesMessage。 ConnectionFactory: ​ 连接工厂。用于创建连接 Connection: ​ 连接。用于和ActiveMQ建立连接，一般由ConnectionFactory创建 Session: ​ 会话。Session是操作消息的接口。可以通过session创建生产者、消费者、消息等信息。Session支持事务特征，当需要批处理（发送或者接收）消息的时候，可以将这些操作放到一个事务中进行。 Queue和Topic: ​ Queue - 队列目的地。Topic - 主题目的地。都是Destination的子接口。 　Queue：一般队列中的一条消息，默认的只能被一个消费者消费。消费完成即删除。 　Topic：消息会发送给所有订阅的消费者。消息不会持久化，也即如果发消息时不存在订阅关系，则消息直接丢弃。 下图是JMS规范中 API Interface: 图4 JMS Classic API Interface 图5 Simplied API Interface 图5 JMS Queue API 图7 Publish-Subscribe API 从上面的API图感悟： 对于这种C-S模式的应用来说，都是由 ConnectionFactory -获取-> Connection-获取-> Session->Session做具体的操作 具体的例子有：JMS，数据库连接池(datasource) 图8 C-S模式下的交互 首先创建连接，然后获取连接中的会话。在会话中完成具体的和服务端的交互。 5.active mq使用例子 5.1 下载安装activeMQ 5.2 将activeMQ的bin目录添加到path路径下 5.3 activemq start 启动mq ​ 注意：activemq使用tcp://ip:61616 传递消息 ​ activemq页面管理 ip:8161/admin 用户名/密码 amdin/admin Producer package com.cfang.mq.simpleCase; import javax.jms.Connection; import javax.jms.ConnectionFactory; import javax.jms.Destination; import javax.jms.JMSException; import javax.jms.Message; import javax.jms.MessageProducer; import javax.jms.Session; import org.apache.activemq.ActiveMQConnectionFactory; public class SimpleProducer { public static void main(String[] args) { SimpleProducer simpleProducer = new SimpleProducer(); simpleProducer.sendMsg(\"我有一只小毛驴\"); } public void sendMsg(String msg) { ConnectionFactory factory = null; //连接工厂 Connection connection = null; //连接对象 Session session = null; //session会话 Destination destination = null; //目的地 MessageProducer producer = null; //生产者 Message message = null; //消息 try { //创建连接工厂，前两个参数是做安全认证使用，本例中尚未开启。 factory = new ActiveMQConnectionFactory(null, null, \"tcp://172.31.31.160:61616\"); //通过工厂创建连接对象 connection = factory.createConnection(); //启动连接。生产者通常来说不是必须显式启动的，在发送消息的时候，会检测是否启动，未启动的话会先进行启动操作。 connection.start(); /** * 根据连接对象信息，创建session会话信息。 * 第一个参数为是否开启事务特性。 * false - 不开启事务。使用比较多的配置。 * true - 开启事务。如果开启事务，这第二个参数默认无效了，建议还是写成Session.SESSION_TRANSACTED * 第二个参数表示消息确认机制。 * AUTO_ACKNOWLEDGE - 自动消息确认。消息消费者接受处理消息后，自动发送确认信息 * CLIENT_ACKNOWLEDGE - 手动确认。消息消费者在接受处理消息后，必须手动发起确认ack信息 * DUPS_OK_ACKNOWLEDGE - 有副本的手动确认机制。 */ session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //创建目的地，参数是目的地名称，也即队列名。 destination = session.createQueue(\"tp_simple_queue\"); //创建消息生产者，参数为目的地，也可以不指定，在发送消息的时候再指定 producer = session.createProducer(destination); //创建消息 message = session.createTextMessage(msg); //发送到ActiveMQ指定的目的地中 producer.send(message); System.out.println(\"=====send msg ok!=====\"); } catch (Exception e) { e.printStackTrace(); } finally { // 回收资源 if(producer != null){ // 回收消息发送者 try { producer.close(); } catch (JMSException e) { e.printStackTrace(); } } if(session != null){ // 回收会话对象 try { session.close(); } catch (JMSException e) { e.printStackTrace(); } } if(connection != null){ // 回收连接对象 try { connection.close(); } catch (JMSException e) { e.printStackTrace(); } } } } } Consumer package com.cfang.mq.simpleCase; import javax.jms.Connection; import javax.jms.ConnectionFactory; import javax.jms.Destination; import javax.jms.JMSException; import javax.jms.Message; import javax.jms.MessageConsumer; import javax.jms.Session; import javax.jms.TextMessage; import org.apache.activemq.ActiveMQConnectionFactory; public class SimpleConsumer { public static void main(String[] args) { SimpleConsumer simpleConsumer = new SimpleConsumer(); System.out.println(\"=====receive msg: \" + simpleConsumer.receiveMsg()); } public String receiveMsg() { String result = \"\"; ConnectionFactory factory = null; //连接工厂 Connection connection = null; //连接对象 Session session = null; //session会话 Destination destination = null; //目的地 MessageConsumer consumer = null; //生产者 Message message = null; //消息 try { factory = new ActiveMQConnectionFactory(null, null, \"tcp://172.31.31.160:61616\"); connection = factory.createConnection(); //不同于生产者存在自动启动机制，消息的消费者必须显式的手动启动连接 connection.start(); session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //创建目的地，参数是目的地名称，也即队列名。 destination = session.createQueue(\"tp_simple_queue\"); //创建消费者，参数为目的地，也可以不指定，在发送消息的时候再指定 consumer = session.createConsumer(destination); //接收一条消息 message = consumer.receive(); //手动确认 // message.acknowledge(); result = ((TextMessage)message).getText(); } catch (Exception e) { e.printStackTrace(); } finally { // 回收资源 if(consumer != null){ // 回收消息发送者 try { consumer.close(); } catch (JMSException e) { e.printStackTrace(); } } if(session != null){ // 回收会话对象 try { session.close(); } catch (JMSException e) { e.printStackTrace(); } } if(connection != null){ // 回收连接对象 try { connection.close(); } catch (JMSException e) { e.printStackTrace(); } } } return result; } } 6.总结 1.了解消息队列的概念 2.了解JMS规范中规定的接口说明 3.了解ActiveMQ使用方式 4.了解消息队列的使用场景 7.参考 https://www.jianshu.com/p/9a0e9ffa17dd https://blog.csdn.net/qq_33404395/article/details/80590113 https://www.cnblogs.com/eric-fang/p/11314191.html https://www.cnblogs.com/williamjie/p/9481780.html 8.QA a.如何保证消息不被重复消费 ​ 消费者在发送消息的时候，消息消费完毕之后，会发送一个确认消息给消息队列，消息队列就知道消息被消费了，就会将该消息从消息队列中删除（类似TCP握手时的确认)。只是不同的消息队列发送的确认信息形式不同,例如RabbitMQ是发送一个ACK确认消息，RocketMQ是返回一个CONSUME_SUCCESS成功标志，kafka实际上有个offset的概念，简单说一下(如果还不懂，出门找一个kafka入门到精通教程),就是每一个消息都有一个offset，kafka消费过消息后，需要提交offset，让消息队列知道自己已经消费过了。那造成重复消费的原因?，就是因为网络传输等等故障，确认信息没有传送到消息队列，导致消息队列不知道自己已经消费过该消息了，再次将该消息分发给其他的消费者。 如何解决?这个问题针对业务场景来答分以下几点   (1)比如，你拿到这个消息做数据库的insert操作。那就容易了，给这个消息做一个唯一主键，那么就算出现重复消费的情况，就会导致主键冲突，避免数据库出现脏数据。   (2)再比如，你拿到这个消息做redis的set的操作，那就容易了，不用解决，因为你无论set几次结果都是一样的，set操作本来就算幂等操作。   (3)如果上面两种情况还不行，上大招。准备一个第三方介质,来做消费记录。以redis为例，给消息分配一个全局id，只要消费过该消息，将以K-V形式写入redis。那消费者开始消费前，先去redis中查询有没消费记录即可。 采用确认模式的消息队列： 图9 采用确认模式的消息队列 b.如何保证消息的顺序性 分析:其实并非所有的公司都有这种业务需求，但是还是对这个问题要有所复习。 回答:针对这个问题，通过某种算法，将需要保持先后顺序的消息放到同一个消息队列中(kafka中就是partition,rabbitMq中就是queue)。然后只用一个消费者去消费该队列。 有的人会问:那如果为了吞吐量，有多个消费者去消费怎么办？ 这个问题，没有固定回答的套路。比如我们有一个微博的操作，发微博、写评论、删除微博，这三个异步操作。如果是这样一个业务场景，那只要重试就行。比如你一个消费者先执行了写评论的操作，但是这时候，微博都还没发，写评论一定是失败的，等一段时间。等另一个消费者，先执行写评论的操作后，再执行，就可以成功。 总之，针对这个问题，我的观点是保证入队有序就行，出队以后的顺序交给消费者自己去保证，没有固定套路。 c.如何保证消费的可靠性传输 分析：在使用消息队列的过程中，应该做到消息不能多消费，也不能少消费。每种MQ都要从三个角度来分析:生产者弄丢数据、消息队列弄丢数据、消费者弄丢数据 c.1 生产者丢数据 从生产者弄丢数据这个角度来看，RabbitMQ提供transaction和confirm模式来确保生产者不丢消息。 transaction机制就是说，发送消息前，开启事物(channel.txSelect())，然后发送消息，如果发送过程中出现什么异常，事物就会回滚(channel.txRollback())，如果发送成功则提交事物(channel.txCommit())。 然而缺点就是吞吐量下降了。因此，按照博主的经验，生产上用confirm模式的居多。一旦channel进入confirm模式，所有在该信道上面发布的消息都将会被指派一个唯一的ID(从1开始)，一旦消息被投递到所有匹配的队列之后，rabbitMQ就会发送一个Ack给生产者(包含消息的唯一ID)，这就使得生产者知道消息已经正确到达目的队列了.如果rabiitMQ没能处理该消息，则会发送一个Nack消息给你，你可以进行重试操作 图10 事务执行过程 开启事务（Begin Transaction），如果事务在执行过程中出错则回滚（Rollback），否则提交（Commit） public void transactionalMethod(Session session){ try{ //开启事务 session.beginTransaction(); //处理业务逻辑，例如：SQL语句 session.doMethod(); //如果上面方法执行成功，则走到下面这一步：这个很关键 //提交事务:说明上面的业务肯定成功执行了 session.commit(); }catch(Exception e){ //如果处理业务逻辑出错 //进行业务回滚 session.rollBack(); }finally{ //关闭session session.close(); } } //上面的思想很关键，基本就是Spring @Transactional注解的处理方式. c.2 消息队列丢数据 处理消息队列丢数据的情况，一般是开启持久化磁盘的配置。这个持久化配置可以和confirm机制配合使用，你可以在消息持久化磁盘后，再给生产者发送一个Ack信号。这样，如果消息持久化磁盘之前，rabbitMQ阵亡了，那么生产者收不到Ack信号，生产者会自动重发 这个思想和上面的是一样的，都是先做可能出错的操作，如果操作安全/成功 完成，再发送确认信号 c.3 消费者丢数据 这种情况一般是自动提交了offset，然后你处理程序过程中挂了。kafka以为你处理好了。再强调一次offset是干嘛的 offset：指的是kafka的topic中的每个消费组消费的下标。简单的来说就是一条消息对应一个offset下标，每次消费数据的时候如果提交offset，那么下次消费就会从提交的offset加一那里开始消费。 比如一个topic中有100条数据，我消费了50条并且提交了，那么此时的kafka服务端记录提交的offset就是49(offset从0开始)，那么下次消费的时候offset就从50开始消费。 解决方案也很简单，改成手动提交即可。 意思：就是先做了确认操作，然后消费消息。这样的危险时处理消息时候报错。改为先消费消息，成功后手动发送确认 "},"java/microservice/rpc/":{"url":"java/microservice/rpc/","title":"1.4.2 RPC","keywords":"","body":"RPC 目录： 简介 原理 参考资料 1.简介 RPC就是远程过程调用协议，其作用就是客户端与服务端之间的远程调用，就像本地自己调用一样。微服务的基础。 2.原理 RPC（Remote Procedure Call）远程过程调用，简单的理解是一个节点请求另一个节点提供的服务 本地过程调用：如果需要将本地student对象的age+1，可以实现一个addAge()方法，将student对象传入，对年龄进行更新之后返回即可，本地方法调用的函数体通过函数指针来指定。 远程过程调用：上述操作的过程中，如果addAge()这个方法在服务端，执行函数的函数体在远程机器上，如何告诉机器需要调用这个方法呢？ 首先客户端需要告诉服务器，需要调用的函数，这里函数和进程ID存在一个映射，客户端远程调用时，需要查一下函数，找到对应的ID，然后执行函数的代码。 客户端需要把本地参数传给远程函数，本地调用的过程中，直接压栈即可，但是在远程调用过程中不再同一个内存里，无法直接传递函数的参数，因此需要客户端把参数转换成字节流，传给服务端，然后服务端将字节流转换成自身能读取的格式，是一个序列化和反序列化的过程。 3.数据准备好了之后，如何进行传输？网络传输层需要把调用的ID和序列化后的参数传给服务端，然后把计算好的结果序列化传给客户端，因此TCP层即可完成上述过程，gRPC中采用的是HTTP2协议。 图1 RPC调用原理 RPC框架的实现 RPC能够让本地应用简单、高效地调用服务器中的过程（服务）。它主要应用在分布式系统。如Hadoop中的IPC组件。但怎样实现一个RPC框架呢？ 从下面几个方面思考，仅供参考： 1.通信模型：假设通信的为A机器与B机器，A与B之间有通信模型，在Java中一般基于BIO或NIO；。 2.过程（服务）定位：使用给定的通信方式，与确定IP与端口及方法名称确定具体的过程或方法； 3.远程代理对象：本地调用的方法(服务)其实是远程方法的本地代理，因此可能需要一个远程代理对象，对于Java而言，远程代理对象可以使用Java的动态对象实现，封装了调用远程方法调用； 4.序列化，将对象名称、方法名称、参数等对象信息进行网络传输需要转换成二进制传输，这里可能需要不同的序列化技术方案。如:thrift,protobuf,Arvo,msgback等。 3.参考资料 https://www.cnblogs.com/zyl2016/p/9875593.html https://www.jianshu.com/p/7d6853140e13 "},"java/tomcatxjetty/":{"url":"java/tomcatxjetty/","title":"1.5 Tomcat & Jetty","keywords":"","body":""},"java/tomcatxjetty/tomcat/framework/":{"url":"java/tomcatxjetty/tomcat/framework/","title":"1.5.1 tomcat架构","keywords":"","body":"Tomcat架构 "},"java/asmxjavassit/":{"url":"java/asmxjavassit/","title":"1.6 Asm & Javassist","keywords":"","body":""},"java/jndi/":{"url":"java/jndi/","title":"1.7 Jndi","keywords":"","body":"JNDI - Java Naming and Directory Interface 目录： 简介 实例 总结 参考 1.简介 JNDI(Java Naming and Directory Interface，Java命名和目录接口)是一组在Java应用中访问命名和目录服务的API。命名服务将名称和对象联系起来，使得我们可以用名称访问对象。 JNDI类似于JDBC一样,提供了一系列编程接口,用来规范命名服务中对象的创建和管理,通过JNDI可以实现对象的创建与托管,和对象的使用过程完全解耦. 比如:在application的底层创建对象,并将对象bind到特定的context中,对象的创建过程或者\"查找\"方式只有此底层模块支持,外部程序不可见.对于对象的使用者(调用者)只能通过JNDI的方式获取对象,对象使用者无法直接创建对象等. ​ 在JMS，JMail,JDBC,EJB等技术中，就大量应用的这种技术。JNDI可访问的现有的目录及服务有：DNS、XNam 、Novell目录服务、LDAP(Lightweight Directory Access Protocol 轻型目录访问协议)、 CORBA对象服务、文件系统、Windows XP/2000/NT/Me/9x的注册表、RMI、DSML v1&v2、NIS。 ​ jndi诞生的理由似乎很简单。随着分布式应用的发展，远程访问对象访问成为常用的方法。虽然说通过Socket等编程手段仍然可实现远程通信，但按照模式的理论来说，仍是有其局限性的。RMI技术，RMI-IIOP技术的产生，使远程对象的查找成为了技术焦点。JNDI技术就应运而生。JNDI技术产生后，就可方便的查找远程或是本地对象。 ​ 就是不要在程序中直接new资源。而是把资源的配置放到程序之外(配置文件)，通过JNDI来管理资源对象。 图1 JNDI架构 ​ 如图，从下往上看。JNDI SPI厂商都有对应的LDAP，DNS，NIS等的实现。这些技术几乎都涉及到资源的使用。这些资源对象统一由Naming Manager进行管理。程序只需要使用JNDI API通过资源名称获取相应的资源即可。 2.实例 使用JDBC连接数据库： Connection conn=null; try { Class.forName(\"com.mysql.jdbc.Driver\", true, Thread.currentThread().getContextClassLoader()); conn=DriverManager.getConnection(\"jdbc:mysql://MyDBServer?user=xxx&password=xxx\"); ...... conn.close(); } catch(Exception e) { e.printStackTrace(); } finally { if(conn!=null) { try { conn.close(); } catch(SQLException e) {} } 使用JNDI做法： 配置数据源:(配置数据源的位置根据具体的web服务器决定) MySqlDS jdbc:mysql://localhost:3306/lw com.mysql.jdbc.Driver root rootpassword org.jboss.resource.adapter.jdbc.vendor.MySQLExceptionSorter mySQL 使用JNDI连接数据库： Connection conn=null; try { Context ctx = new InitialContext(); Object datasourceRef = ctx.lookup(\"java:MySqlDS\"); //引用数据源 DataSource ds = (Datasource) datasourceRef; conn = ds.getConnection(); ...... c.close(); } catch(Exception e) { e.printStackTrace(); } finally { if(conn!=null) { try { conn.close(); } catch(SQLException e) {} } 这样的好处就是，不需要在程序中管理资源的配置的具体信息。如果遇到更改资源配置的场景，只需要更改配置，而不需要更改代码。 辨析：context.lookup(\"java:comp/env/XXX\")和context.lookup(\"XXX\")的区别。 Answer：context.loopup(\"java:comp/env/XXX\")只能用在J2EE环境，也就是Web项目。而context.lookup(\"XXX\")可以用在任何环境，只需要\"XXX\"是一个JNDI资源名字即可。 3.总结 1.了解JNDI 2.了解JNDI的架构 3.了解JNDI思想：将由JNDI管理的资源以：名字-资源对象 的方式管理起来，程序通过名字来检索对象。 4.了解JNDI例子 4.参考 https://blog.csdn.net/wn084/article/details/80729230 https://www.iteye.com/blog/shift-alt-ctrl-1971329 http://www.atguigu.com/jsfx/1399.html https://yq.aliyun.com/articles/533367?spm=a2c4e.11153940.0.0.278265e2Z66a2E "},"java/maven/":{"url":"java/maven/","title":"1.8 maven","keywords":"","body":"Maven "},"java/maven/reactor/":{"url":"java/maven/reactor/","title":"1.8.1 maven反应堆","keywords":"","body":"Maven反应堆 1.简介 在一个多模块的Maven项目中，反应堆（Reactor）是指所有模块组成的一个构建结构，对于单个模块的项目，反应堆就是该模块本身，但对于多模块项目来说，反应堆就包含了各模块之间继承与依赖的关系，从而能够自动计算出合理的模块构建顺序，但有些时候，用户想要仅仅构建完整反应堆中的某些个模块，Maven 提供很多的命令行选项支持裁剪反应堆，裁剪参数列表如下： -am，--also-make：同时构建所列模块的依赖模块 -amd，-also-make-dependents：同时构建依赖于所列模块的模块 -pl，--projects：构建指定的模块，模块间用逗号分隔 -rf，-resume-from：在完整的反应堆构建顺序基础上指定从哪个模块开始构建 2.例子 某个项目的完整反应堆如下： whole-project ​ A-module ​ B-module ​ C-module 制定构建某些模块： mvn clean -pl B-module // 构建B-module mvn clean -pl B-Module -am. //构建B-module及其依赖的模块 mvn clean -pl B-module -amd. // 构建B-module及其依赖B的模块 mvn clean -rf B-module //从反应堆B-module位置开始构建 3.参考资料 https://blog.csdn.net/casablancaagnes_3sdf/article/details/73865382 "},"spring framework/":{"url":"spring framework/","title":"2.Spring Framework","keywords":"","body":""},"spring framework/spring-core/":{"url":"spring framework/spring-core/","title":"2.1 Spring-Core","keywords":"","body":""},"spring framework/spring-core/spring-event/":{"url":"spring framework/spring-core/spring-event/","title":"2.1.1 Spring事件发布","keywords":"","body":"Spring事件发布 目录： 简介 源码分析 总结 参考资料 1.简介 Spring中的事件通知机制是观察者模式的一种实现。观察者是ApplicaitonListener，观察者感兴趣的是某种状态的变化，这种变化使用ApplicaitonEvent来传达，也就是事件对象。Spring中的事件包括 : ContextStartedEvent(容器启动事件)，ContextStopEvent（容器停止事件），ContextRefreshEvent(容器重启事件)，ContextClosedEvent（容器关闭事件)。 图1 事件发布和通知 如图所示，是事件发布的一个大体流程。首先容器（Spring容器，Servlet容器/即tomcat服务器）注册监听器用来监听特定的事件；然后容器发布特定类型的事件，然后进行事件通知/事件广播通知已经注册的监听器用来处理 sequenceDiagram 客户端->>Spring容器/Servlet容器:1.注册监听特定事件的监听器 Spring容器/Servlet容器->>Spring容器/Servlet容器:2.发布特定类型的事件 Spring容器/Servlet容器->>容器中其他模块:3.广播事件 容器中其他模块->>容器中其他模块:4.对特定的广播事件进行相应 图2 事件发布和通知时序图 2.源码分析 sequenceDiagram AbstractApplicationContext->>AbstractApplicationContext:publishEvent(Object event) 发布事件 AbstractApplicationContext->>ApplicationEventMulticaster:multicastEvent(ApplicationEvent) 广播事件 ApplicationEventMulticaster->>ApplicationEventMulticaster:getApplicationListeners(ApplicationEvent,ResolvableType) 获取相应事件的监听器 ApplicationEventMulticaster->>ApplicationEventMulticaster:invokeListener(ApplicationListener listener , ApplicationEvent event) 触发事件 图3 Spring事件发布代码时序图 3.总结 事件发布适用于某些容器/系统中 产生各种事件的情况。要考虑到事件所在的上下文（容器/系统） 4.参考资料 https://www.toutiao.com/a6602764338715427336/ https://www.toutiao.com/a6602764338715427336/ https://www.toutiao.com/a6770321822299718151/ https://www.toutiao.com/a6758771082041246222/ https://www.cnblogs.com/vettel0329/p/11269733.html https://www.cnblogs.com/xinde123/p/8918714.html (推荐) "},"spring framework/spring-core/spring-beanfactory/":{"url":"spring framework/spring-core/spring-beanfactory/","title":"2.1.2 Spring容器继承关系","keywords":"","body":"Spring容器继承关系 目录: 简介 容器继承关系 BeanFactory和ApplicationContext区别 参考资料 1.简介 Spring容器(Spring Container)可以理解为生产对象(OBJECT/BEAN)的地方，容器负责对象的整个生命周期(LifeCycle)，创建、装配、销毁。而这里面对象的生命周期管理都交给Spring容器，这种编程模型成为-控制反转(Inversion of Control),容器称为IOC容器。而这里面的IOC容器并不只是Spring才有，很多框架也有该技术 2.容器继承关系 如图,下面是Spring容器类继承关系. 图1 Spring容器类继承关系 Spring容器最基本的接口就是BeanFactory。BeanFactory负责配置、创建、管理Bean，它有一个子接口ApplicationContext，也被称为Spring上下文，容器同时还管理着Bean和Bean之间的依赖关系。 spring Ioc容器的实现，从根源上是beanfactory，但真正可以作为一个可以独立使用的ioc容器还是DefaultListableBeanFactory，因此可以这么说， DefaultListableBeanFactory 是整个spring ioc的始祖. 2.1 接口说明 BeanFactory Spring容器根接口，提供 获取bean,判断是否包含bean,判断是否是singleton/prototype,获取bean类型,获取bean别名 图片 This interface is implemented by objects that hold a number of bean definitions, each uniquely identified by a String name. Depending on the bean definition, the factory will return either an independent instance of a contained object (the Prototype design pattern), or a single shared instance Bean factory implementations should support the standard bean lifecycle interfaces as far as possible. The full set of initialization methods and their standard order is: BeanNameAware's setBeanName BeanClassLoaderAware's setBeanClassLoader BeanFactoryAware's setBeanFactory EnvironmentAware's setEnvironment EmbeddedValueResolverAware's setEmbeddedValueResolver ResourceLoaderAware's setResourceLoader (only applicable when running in an application context) ApplicationEventPublisherAware's setApplicationEventPublisher (only applicable when running in an application context) MessageSourceAware's setMessageSource (only applicable when running in an application context) ApplicationContextAware's setApplicationContext (only applicable when running in an application context) ServletContextAware's setServletContext (only applicable when running in a web application context) postProcessBeforeInitialization methods of BeanPostProcessors InitializingBean's afterPropertiesSet a custom init-method definition postProcessAfterInitialization methods of BeanPostProcessors On shutdown of a bean factory, the following lifecycle methods apply: postProcessBeforeDestruction methods of DestructionAwareBeanPostProcessors DisposableBean's destroy a custom destroy-method definition HierachicalBeanFactory 提供访问父容器(parent beanfactory)功能 Sub-interface implemented by bean factories that can be part of a hierarchy. The corresponding setParentBeanFactory method for bean factories that allow setting the parent in a configurable fashion can be found in the ConfigurableBeanFactory interface. method: getParentBeanFactory():BeanFactory returns the parent bean factory,or null if there is none. containsLocalBean(String):boolean Return whether the local bean factory contains a bean of the given name, ignoring beans defined in ancestor contexts. This is an alternative to containsBean, ignoring a bean of the given name from an ancestor bean factory. ListablebeanFactory 批量获取Bean Extension of the BeanFactory interface to be implemented by bean factories that can enumerate all their bean instances, rather than attempting bean lookup by name one by one as requested by clients. BeanFactory implementations that preload all their bean definitions (such as XML-based factories) may implement this interface. AutowireCapableBeanFactory 在BeanFactory基础上实现对已存在示例的管理，容器提供自动装配(autowiring)功能 Extension of the BeanFactory interface to be implemented by bean factories that are capable of autowiring, provided that they want to expose this functionality for existing bean instances. ConfigurableBeanFactory 单例bean的注册，生成实例 Configuration interface to be implemented by most bean factories. Provides facilities to configure a bean factory, in addition to the bean factory client methods in the BeanFactory interface. ConfigurableListableBeanFactory 继承了上述的所有接口，增加了其他功能：比如类加载器,类型转化,属性编辑器,BeanPostProcessor,作用域,bean定义,处理bean依赖关系, bean如何销毁… Configuration interface to be implemented by most listable bean factories. In addition to ConfigurableBeanFactory, it provides facilities to analyze and modify bean definitions, and to pre-instantiate singletons. DefaultListableBeanFactory 实现了ConfigurableListableBeanFactory，实现上述BeanFactory所有功能。它还可以注册BeanDefinition 3.BeanFactory和ApplicationContext区别 BeanFactory和ApplicationContext是Spring两大核心接口,而其中ApplicationContext是BeanFactory的子接口.它们都可以当作Spring容器,Spring容器是生成Bean实例的工厂,并管理容器中的Bean.在基于Spring的javaEE应用中,所有的组件(Component)都被当作Bean处理，包括数据源(DataSource),Hibernate的SessionFactory、事务管理器(TransactionManager). Spring的核心是容器(Spring Container),框架本身提供了很多个容器的实现。大概分为两种类型： BeanFactory: 提供基本的DI(Dependency Injection). ApplicationContext: 提供更多企业级服务，例如解析配置文本信息等等。 BeanFactory更专注与保存Bean,解析Bean之间的关系,重点是Factory.而ApplicationContext更在于从应用的全局角度看待问题,翻译为\"应用上下文\",代表整个应用的情况,并且提供更多的企业级别服务,而且ApplicationContext里面持有BeanFactory的引用,默认是DefaultListableBeanFactory. ApplicationContext常用类 ApplicationContext常用实现类 作用 AnnotationConfigApplicationContext 从一个或多个基于java配置类加载上下文定义,适用于java注解的方式 ClassPathXmlApplicationContext 从类路径下的一个或多个xml配置文件中加载上下文定义,适用于xml配置方式 FileSystemXmlApplicationContext 从文件系统下的一个或多个xml配置文件中加载上下文定义,适用于xml配置方式 AnnotationConfigWebApplicationContext 专门为web应用准备的，适用于注解方式 XmlWebApplicationContext 从web应用下的一个或多个xml配置文件加载上下文定义，适用于xml配置方式 Spring具有非常大的灵活性，它提供了三种主要的装配机制： 1. XML显示配置 2. JAVA中进行显示配置（Configuration） 3. 隐式Bean发现机制和自动装配 3.1 组件扫描(Component Scan)：Spring会自动发现应用上下文中所创建的Bean 3.2 自动装配(autowiring):Spring会自动满足Bean之间的依赖 例子： 1.通过XML文件配置 2.通过JAVA注解的方式配置 @Configuration public class Config{ //Spring autowiring A of B @Bean public B b(A a){ return new B(a); } @Bean public A a(){ return new A(); } } 3.Spring隐式Bean发现 @Component public class MyComponent{ } 注意：组件扫描默认情况下不请用，需要配置. @ComponenetScan @Configuration public class Config{} 在Config类中添加@ComponentScan表示开启组件扫描,默认扫描与配置类相同的包。 4.参考资料 https://www.pianshen.com/article/6729221959/ "},"spring framework/spring-core/spring-cycle-depend/":{"url":"spring framework/spring-core/spring-cycle-depend/","title":"2.1.3 Spring循环依赖问题","keywords":"","body":"Spring循环依赖问题 目录: 简介 Spring循环依赖产生场景 解决方法 总结 参考资料 1.简介 循环依赖(cycle-dependency)是指对象间的依赖形成了一个环(loop),如下 A---->B----->C ^ | | v ------------D 其中A依赖B,B依赖C,C依赖D,D依赖A,这种依赖关系形成了一个环。当Spring容器中Bean之间的产生循环依赖时，如果不加以解决,会出现异常. 2.Spring循环依赖产生场景 如图所示,A、B、C之间形成了循环依赖.当Spring容器想要创建A对象时,发现A依赖了B,这是Spring就不会实例化(Instantiate)对象A,而是回去实例化对象B;当Spring容器想要实例化B的时候,发现B依赖了C,同理Spring容器就去实例化C；当Spring容器实例化C时,发现C依赖了A,Spring就去实例化A;这样Spring容器就会陷入一个环中. 图1 循环依赖 3.解决方法 Spring采用三级缓存的方法来解决循环依赖.Spring解决循环依赖的依据是基于JAVA的引用传递,当获取到对象的引用时,对象field是可以延后设置,但是使用有参数的构造器实例化对象时,需要首先获取到构造器参数的引用. createBeanInstance实例化--->populateBean填充Bean属性--->initializeBean初始化Bean createBeanInstance：实例化Bean，即创建Bean对象，调用类默认的构造方法或者带参数的构造器 populateBean：填充Bean属性，对Bean依赖的属性进行填充 initalizeBean：初始化Bean 从上面讲述的单例bean初始化步骤我们可以知道，循环依赖主要发生在第一、第二步。也就是构造器循环依赖和field循环依赖。 那么我们要解决循环引用也应该从初始化过程着手，对于单例来说，在Spring容器整个生命周期内，有且只有一个对象，所以很容易想到这个对象应该存在Cache中，Spring为了解决单例的循环依赖问题，使用了三级缓存。 如下是Spring三级缓存用来解决循环依赖： /** Cache of singleton objects: bean name --> bean instance */ private final Map singletonObjects = new ConcurrentHashMap(256); /** Cache of singleton factories: bean name --> ObjectFactory */ private final Map> singletonFactories = new HashMap>(16); /** Cache of early singleton objects: bean name --> bean instance */ private final Map earlySingletonObjects = new HashMap(16); singletonObjects ：用来存放单例Bean(已经创建完成的，依赖关系已经满足) -- 一级缓存 earlySingletonObjects: 存放提前曝光的单例对象(实例化完成，但是依赖关系没有满足,即创建中的Bean;与singletonFactoies互斥，即Bean不会同时存在earlySingletonObjects和singetonFactories中) -- 二级缓存 singletonFactoris: 单例对象工厂cache -- 三级缓存 当创建Bean的时候，调用getSingleton接口，首先是从singletonObjects中获取；如果没有再去earlySingletonObjects中获取；如果还是没有则从singletonFactories中获取单例对象，然后将其放到earlySingletonObjects中。下面是Spring容器中具体代码实现 protected Object getSingleton(String beanName, boolean allowEarlyReference) { Object singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null && isSingletonCurrentlyInCreation(beanName)) { synchronized (this.singletonObjects) { singletonObject = this.earlySingletonObjects.get(beanName); if (singletonObject == null && allowEarlyReference) { ObjectFactory singletonFactory = this.singletonFactories.get(beanName); if (singletonFactory != null) { singletonObject = singletonFactory.getObject(); this.earlySingletonObjects.put(beanName, singletonObject); this.singletonFactories.remove(beanName); } } } } return (singletonObject != NULL_OBJECT ? singletonObject : null); } 从上面分析可知，解决问题的关键在于singletonFactories。这个接口在下面被引用 protected void addSingletonFactory(String beanName, ObjectFactory singletonFactory) { Assert.notNull(singletonFactory, \"Singleton factory must not be null\"); synchronized (this.singletonObjects) { if (!this.singletonObjects.containsKey(beanName)) { this.singletonFactories.put(beanName, singletonFactory); this.earlySingletonObjects.remove(beanName); this.registeredSingletons.add(beanName); } } } 如下图,是Spring容器解决循环依赖的逻辑图。我们用AB循环依赖配上下面的图来说明 图2 三级缓存结构 当Spring容器实例化A的时候发现需要B，首先将A放到三级缓存里面去实例B。B实例化的时候需要A，首先B查询一级缓存，发现没有；然后查询二级缓存，知道从三级缓存找到需要的A，然后把A从三级缓存删除并放到二级缓存。此时，B初始化完毕，然后将B放到一级缓存中(此时B中的A依然是创建状态)。此时回来创建A，然后查找B，直接从一级缓存找到B，然后完成A的创建，并将A放到一级缓存中。 单例bean的依赖注入分为构造器注入和setter方法注入。 1，Spring只会解决setter方法注入的循环依赖，构造器注入的循环依赖会抛BeanCurrentlyInCreationException异常。 2，Spring不会解决prototype作用域的bean，因为Spring容器不进行缓存\"prototype\"作用域的bean，因此无法提前暴露一个创建中的bean。如果有循环依赖会抛BeanCurrentlyInCreationException异常。 Spring依赖注入方式 接口注入 Setter方法注入 构造方法注入 Spring容器无法解决构造器循环依赖(构造器循环依赖：即各个依赖Bean之间是使用有参数的构造器实例化)的原因：依然使用AB举例，Spring容器想要实例化A，但是发现A的构造器依赖B，这是就不实例化A(注意和setter方法注入的区别)，进而去实例化B；Spring容器实例化B的时候，发现B的构造器依赖A，这时就去实例化A，到此就发生了循环依赖的问题。由于构造器依赖无法先生成实例，所以Spring容器无法解决此类的循环依赖。 4.总结 了解什么是循环依赖，循环依赖产生的原因和场景。Spring容器通过三级缓存的方式解决循环依赖，但是只能够解决单例setter注入的循环依赖，而不能解决原型Bean，构造器注入的循环依赖。 5.参考资料 https://blog.csdn.net/lovewebeye/article/details/105508729 https://blog.csdn.net/chen2526264/article/details/80673598 https://blog.csdn.net/qq_36381855/article/details/79752689(推荐) https://blog.csdn.net/itmrchen/article/details/90201279 "},"spring framework/spring-core/spring-defaultlistablebeanfactory/":{"url":"spring framework/spring-core/spring-defaultlistablebeanfactory/","title":"2.1.4 Spring DefaultListableBeanFactory","keywords":"","body":"Spring DefaultListableBeanFactory 目录: 简介 通过DefaultListableBeanFactory向容器中注册Bean 了解Spring启动过程 参考资料 1.简介 Spring's default implementation of the ConfigurableListableBeanFactory and BeanDefinitionRegistry interfaces: a full-fledged bean factory based on bean definition metadata, extensible through post-processors. Typical usage is registering all bean definitions first (possibly read from a bean definition file), before accessing beans. Bean lookup by name is therefore an inexpensive operation in a local bean definition table, operating on pre-resolved bean definition metadata objects. Spring对ConfigurableListableBeanFactory和BeanDefinitionRegistry接口的默认实现。 2.通过DefaultListableBeanfactory向容器中注册Bean 在实际开发中,通常要调用Spring容器的接口向容器中注册其它组件(Component/Bean).下面的代码展示了如何通过DefaulltListableBeanFactory接口向Spring容器中注册Bean. // acquire ApplicationContext reference ConfigurableApplicationContext context = (ConfigurableApplicationContext) applicationContext; DefaultListableBeanFactory beanFactory = (DefaultListableBeanFactory)context.getBeanFactory(); // registry signleton bean beanFactory.registerBeanDefinition(beanName,beanDefinition); 3.Spring启动过程 容器整体概览 Spring启动时读取应用程序提供的Bean配置信息(XML文件,JAVA配置,Bean隐式发现和自动装配),并在Spring容器中生成一份相应的Bean配置注册表,然后根据注册表实例化Bean, 装配Bean之间的依赖关系.然后为上层应用提供准备就绪的运行环境. 图1 Spring装配Bean 内部工作机制 图2 Spring容器内部工作机制 １、ResourceLoader从存储介质中加载Spring配置信息，并使用Resource表示这个配置文件的资源； ２、BeanDefinitionReader读取Resource所指向的配置文件资源，然后解析配置文件。配置文件中每一个解析成一个BeanDefinition对象，并保存到BeanDefinitionRegistry中； ３、容器扫描BeanDefinitionRegistry中的BeanDefinition，使用Java的反射机制自动识别出Bean工厂后处理后器（实现BeanFactoryPostProcessor接口）的Bean，然后调用这些Bean工厂后处理器对BeanDefinitionRegistry中的BeanDefinition进行加工处理。主要完成以下两项工作： 1）对使用到占位符的元素标签进行解析，得到最终的配置值，这意味对一些半成品式的BeanDefinition对象进行加工处理并得到成品的BeanDefinition对象； 2）对BeanDefinitionRegistry中的BeanDefinition进行扫描，通过Java反射机制找出所有属性编辑器的Bean（实现java.beans.PropertyEditor接口的Bean），并自动将它们注册到Spring容器的属性编辑器注册表中（PropertyEditorRegistry）； 4．Spring容器从BeanDefinitionRegistry中取出加工后的BeanDefinition，并调用InstantiationStrategy着手进行Bean实例化的工作； 5．在实例化Bean时，Spring容器使用BeanWrapper对Bean进行封装，BeanWrapper提供了很多以Java反射机制操作Bean的方法，它将结合该Bean的BeanDefinition以及容器中属性编辑器，完成Bean属性的设置工作； 6．利用容器中注册的Bean后处理器（实现BeanPostProcessor接口的Bean）对已经完成属性设置工作的Bean进行后续加工，直接装配出一个准备就绪的Bean。 Spring容器确实堪称一部设计精密的机器，其内部拥有众多的组件和装置。Spring的高明之处在于，它使用众多接口描绘出了所有装置的蓝图，构建好Spring的骨架，继而通过继承体系层层推演，不断丰富，最终让Spring成为有血有肉的完整的框架。所以查看Spring框架的源码时，有两条清晰可见的脉络： 1）接口层描述了容器的重要组件及组件间的协作关系； 2）继承体系逐步实现组件的各项功能。 接口层清晰地勾勒出Spring框架的高层功能，框架脉络呼之欲出。有了接口层抽象的描述后，不但Spring自己可以提供具体的实现，任何第三方组织也可以提供不同实现， 可以说Spring完善的接口层使框架的扩展性得到了很好的保证。纵向继承体系的逐步扩展，分步骤地实现框架的功能，这种实现方案保证了框架功能不会堆积在某些类的身上，造成过重的代码逻辑负载，框架的复杂度被完美地分解开了。 Spring组件按其所承担的角色可以划分为两类： 1）物料组件：Resource、BeanDefinition、PropertyEditor以及最终的Bean等，它们是加工流程中被加工、被消费的组件，就像流水线上被加工的物料； 2）加工设备组件：ResourceLoader、BeanDefinitionReader、BeanFactoryPostProcessor、InstantiationStrategy以及BeanWrapper等组件像是流水线上不同环节的加工设备，对物料组件进行加工处理。 Spring什么时候实例化bean，首先要分2种情况 第一：如果你使用BeanFactory作为Spring Bean的工厂类，则所有的bean都是在第一次使用该Bean的时候实例化 第二：如果你使用ApplicationContext作为Spring Bean的工厂类，则又分为以下几种情况： （1）：如果bean的scope是singleton的，并且lazy-init为false（默认是false，所以可以不用设置），则ApplicationContext启动的时候就实例化该Bean，并且将实例化的Bean放在一个map结构的缓存中，下次再使用该Bean的时候，直接从这个缓存中取 （2）：如果bean的scope是singleton的，并且lazy-init为true，则该Bean的实例化是在第一次使用该Bean的时候进行实例化 （3）：如果bean的scope是prototype的，则该Bean的实例化是在第一次使用该Bean的时候进行实例化 Spring容器初始化过程 图3 Spring容器初始化过程 PropertyEditor 在Spring配置文件里，我们往往通过字面值为Bean各种类型的属性提供设置值：不管是double类型还是int类型，在配置文件中都对应字符串类型的字面值。BeanWrapper填充Bean属性时如何将这个字面值转换为对应的double或int等内部类型呢？我们可以隐约地感觉到一定有一个转换器在其中起作用，这个转换器就是属性编辑器。 PropertyEditor 　　PropertyEditor是属性编辑器的接口，它规定了将外部设置值转换为内部JavaBean属性值的转换接口方法。PropertyEditor主要的接口方法说明如下： Object getValue()：返回属性的当前值。基本类型被封装成对应的包装类实例； void setValue(Object newValue)：设置属性的值，基本类型以包装类传入（自动装箱）； String getAsText()：将属性对象用一个字符串表示，以便外部的属性编辑器能以可视化的方式显示。缺省返回null，表示该属性不能以字符串表示； void setAsText(String text)：用一个字符串去更新属性的内部值，这个字符串一般从外部属性编辑器传入； String[] getTags()：返回表示有效属性值的字符串数组（如boolean属性对应的有效Tag为true和false），以便属性编辑器能以下拉框的方式显示出来。缺省返回null，表示属性没有匹配的字符值有限集合； String getJavaInitializationString()：为属性提供一个表示初始值的字符串，属性编辑器以此值作为属性的默认值。 Spring使用PropertyEditor例子： CustomEditorConfigurer实现BeanFactoryPostProcessor接口，因此是一个Bean工厂后处理器。我们知道Bean工厂后处理器在Spring容器加载配置文件并生成BeanDefinition半成品后就会被自动执行。因此CustomEditorConfigurer有容器启动时有机会注入自定义的属性编辑器 上述XML片段的作用就是，通过字面值\"红旗CA72,200,20000.00\",来创建一个Car对象,通过 CustomCarEditor来完成转换. 　在①处，我们定义了用于注册自定义属性编辑器的CustomEditorConfigurer，Spring容器将通过反射机制自动调用这个Bean。CustomEditorConfigurer通过一个Map属性定义需要自动注册的自定义属性编辑器。在②处，我们为Car类型指定了对应属性编辑器CustomCarEditor，注意键是属性类型，而值是对应的属性编辑器Bean，而不是属性编辑器的类名。 　　最精彩的部分当然是③处的配置，我们原来通过一个元素标签配置好car Bean，然后在boss的中通过ref引用car Bean，但是现在我们直接通过value为car属性提供配置。BeanWrapper在设置boss的car属性时，它将检索自定义属性编辑器的注册表，当发现Car属性类型拥有对应的属性编辑器CustomCarEditor时，它就会利用CustomCarEditor将“红旗CA72,200,20000.00”转换为Car对象 -- 引用自此篇文章 package com.baobaotao.editor; import java.beans.PropertyEditorSupport; public class CustomCarEditor extends PropertyEditorSupport { //1. 将字面值转换为属性类型对象 public void setAsText(String text){ if(text == null || text.indexOf(\",\") == -1){ throw new IllegalArgumentException(\"设置的字符串格式不正确\"); } String[] infos = text.split(\",\"); Car car = new Car(); car.setBrand(infos[0]); car.setMaxSpeed(Integer.parseInt(infos[1])); car.setPrice(Double.parseDouble(infos[2])); //2. 调用父类的setValue()方法设置转换后的属性对象 setValue(car); } } 这是CustomCarEditor的具体实现. 4.参考资料 https://blog.csdn.net/qq_39632561/article/details/83070140(推荐) https://blog.csdn.net/shenchaohao12321/article/details/80295371 引用自此篇文章. https://blog.csdn.net/shenchaohao12321/article/details/80295371 ↩ "},"spring framework/spring-mvc/":{"url":"spring framework/spring-mvc/","title":"2.2 Spring-Mvc","keywords":"","body":""},"spring framework/spring-mvc/spring-mvc-request-annotation/":{"url":"spring framework/spring-mvc/spring-mvc-request-annotation/","title":"2.2.1 SpringMVC注解","keywords":"","body":"SpringMVC注解-Annotated Controllers 目录： 简介 SpringMVC常用注解 handler method arguments 总结 参考资料 1.简介 SpringMVC provides an annotation-based programming model where @Component and @RestContrller components use annotations to express request mappings, request input, exception handling,and more.Annotated controllers have flexible method signatures and do not have to extend 2.springmvc常用注解 @RequestParam @RequestParam annotations to bind servlet request parameters (query paramters , form data) to a method argument in a controller.（key-value. form data(表单数据)也是以key-value传输的） type conversion is automatically applied if the target method parameter type is not String. when an @RequestParam annotation declared as a Map or MultiValueMap argument, the map is populated with all request parameters. 注意：@RequestParam适用于，请求Content-type:text/plan; 或者application/x-www.form-urlencoded。对于form表单来说，post提交会将key-value放在body体中。而get提交会将key-value放在url后面 @RequestParam注解用来处理Content-Type: 为 application/x-www-form-urlencoded编码的内容。提交方式为get或post。（Http协议中，form的enctype属性为编码方式，常用有两种：application/x-www-form-urlencoded和multipart/form-data，默认为application/x-www-form-urlencoded）； @RequestParam注解实质是将Request.getParameter() 中的Key-Value参数Map利用Spring的转化机制ConversionService配置，转化成参数接收对象或字段， get方式中queryString的值，和post方式中body data的值都会被Servlet接受到并转化到Request.getParameter()参数集中，所以@RequestParam可以获取的到； 该注解有三个属性： value、required、defaultValue； value用来指定要传入值的id名称，required用来指示参数是否必录，defaultValue表示参数不传时候的默认值。 @Controller @RequestMapping(value=\"/user\",method={HttpRequestMethod.POST,HttpRequestMethod.GET}) public class UserController{ /** * 获取单个请求参数 */ @RequsetMapping(value=\"/getInfo\") @ResponseBody public User getUser(@RequestParam(\"name\")String name){ // service return user; } } @Controller @RequestMapping(value=\"/user\",method={HttpRequestMethod.POST,HttpRequestMethod.GET}) public class UserController{ /** * 获取全部请求参数 */ @RequsetMapping(value=\"/getInfo\") @ResponseBody public User getUser(@RequestParam Map params){ // service return user; } } @Controller @RequestMapping(value=\"/user\",method={HttpRequestMethod.POST,HttpRequestMethod.GET}) public class UserController{ /** * POST * content-type:application/x-www-urlencoded * form表单单数与User字段属性对应 */ @RequsetMapping(value=\"/addUser\",method={RequestMethod.POST}) @ResponseBody public User addUser(User user){ // service return user; } } @RequestBody you can use the @RequestBody annotation to have the request body read and deserialized info an Object through HttpMessageConverter. @Controller @RequestMapping(value=\"/user\",method={HttpRequestMethod.POST,HttpRequestMethod.GET}) public class UserController{ /** * 请求参数转为对象 */ @RequsetMapping(value=\"/add\") @ResponseBody public HttpEntity addUser(@RequestBody User user){ return HttpEntity.success(); } /** * 前端请求参数为单个: 名称id */ @RequsetMapping(value=\"/add\") @ResponseBody public HttpEntity addUser(@RequestBody Map param){ String id = param.get(\"id\"); return HttpEntity.success(); } } @RequestBody常用来处理Content-type:application/json格式的请求。 需要在pom.xml和springmvc-servlet.xml中配置 pom.xml com.fasterxml.jackson.core jackson-core ${jackson.version} com.fasterxml.jackson.core jackson-databind ${jackson.version} springmvc-servlet.xml @RequestHeader 获取Http请求头部信息 if the target method parameter is not String , type conversion is automatically applied. @GetMapping(\"/demo\") public void handle(@RequestHeader(\"Accept-Encoding\")String encoding, @RequestHeader(\"keep-Alive\")Long keepAlive){ //... } when an @RequestHeader annotation is used on a Map , MultiValueMap,or HttpHeaders,the map is populated with all header values. Built-in support is avaliable for converting a comma-sperated string into an array or collection of strings or other types known to the type conversion system.For example, a method parameter annotated with @RequestHeader(\"Accept\") can be of type String but also String[] or List @GetMapping(\"/demo\") public void handle(@RequestHeader(\"Accept\")String[] accpet){ //... } @CookieValue 获取cookie值 @GetMapping(\"/demo\") public void handle(@CookieValue(\"JSESSIONID\")String cookie){ //... } 3.handler method arguments 4.总结 5.参考资料 https://www.cnblogs.com/haha12/p/10336363.html https://blog.csdn.net/summerSunStart/article/details/78676781 https://blog.csdn.net/outsanding/article/details/80871769 https://blog.csdn.net/lch_2016/article/details/81022646 "},"spring framework/spring-mvc/spring-mvc-interceptor/":{"url":"spring framework/spring-mvc/spring-mvc-interceptor/","title":"2.2.2 SpringMVC拦截器","keywords":"","body":"SpringMVC拦截器 目录： 简介 HandlerInterceptor和WebRequestHandler接口 拦截器处理逻辑 多个拦截器处理流程 Spring和SpringBoot配置拦截器方式 参考资料 1.简介 SpringMVC拦截器(Interceptor)用于实现对每一个请求前后进行相关的业务处理。SpringMVC中的拦截器是通过HandlerInterceptor来实现的。在Spring中定义拦截器方式。 实现Spring的HandlerInterceptor接口 继承实现HandlerInteceptor接口的类，比如Spring已经提供了实现了HandlerInterceptor接口的抽象类HandlerInterceptorAdapter 实现Spring的WebRequestInterceptor接口 继承实现了WebRequestInterceptor接口的类 实现了拦截器后，可以通过重写WebMvcConfigure的addInterceptors方法注册拦截器 2.HandlerInterceptor和WebRequestInteceptor接口 HandlerInteceptor /* * Copyright 2002-2019 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * https://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.springframework.web.servlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.springframework.lang.Nullable; import org.springframework.web.method.HandlerMethod; /** * Workflow interface that allows for customized handler execution chains. * Applications can register any number of existing or custom interceptors * for certain groups of handlers, to add common preprocessing behavior * without needing to modify each handler implementation. * * A HandlerInterceptor gets called before the appropriate HandlerAdapter * triggers the execution of the handler itself. This mechanism can be used * for a large field of preprocessing aspects, e.g. for authorization checks, * or common handler behavior like locale or theme changes. Its main purpose * is to allow for factoring out repetitive handler code. * * In an asynchronous processing scenario, the handler may be executed in a * separate thread while the main thread exits without rendering or invoking the * {@code postHandle} and {@code afterCompletion} callbacks. When concurrent * handler execution completes, the request is dispatched back in order to * proceed with rendering the model and all methods of this contract are invoked * again. For further options and details see * {@code org.springframework.web.servlet.AsyncHandlerInterceptor} * * Typically an interceptor chain is defined per HandlerMapping bean, * sharing its granularity. To be able to apply a certain interceptor chain * to a group of handlers, one needs to map the desired handlers via one * HandlerMapping bean. The interceptors themselves are defined as beans * in the application context, referenced by the mapping bean definition * via its \"interceptors\" property (in XML: a &lt;list&gt; of &lt;ref&gt;). * * HandlerInterceptor is basically similar to a Servlet Filter, but in * contrast to the latter it just allows custom pre-processing with the option * of prohibiting the execution of the handler itself, and custom post-processing. * Filters are more powerful, for example they allow for exchanging the request * and response objects that are handed down the chain. Note that a filter * gets configured in web.xml, a HandlerInterceptor in the application context. * * As a basic guideline, fine-grained handler-related preprocessing tasks are * candidates for HandlerInterceptor implementations, especially factored-out * common handler code and authorization checks. On the other hand, a Filter * is well-suited for request content and view content handling, like multipart * forms and GZIP compression. This typically shows when one needs to map the * filter to certain content types (e.g. images), or to all requests. * * @author Juergen Hoeller * @since 20.06.2003 * @see HandlerExecutionChain#getInterceptors * @see org.springframework.web.servlet.handler.HandlerInterceptorAdapter * @see org.springframework.web.servlet.handler.AbstractHandlerMapping#setInterceptors * @see org.springframework.web.servlet.handler.UserRoleAuthorizationInterceptor * @see org.springframework.web.servlet.i18n.LocaleChangeInterceptor * @see org.springframework.web.servlet.theme.ThemeChangeInterceptor * @see javax.servlet.Filter */ public interface HandlerInterceptor { /** * Intercept the execution of a handler. Called after HandlerMapping determined * an appropriate handler object, but before HandlerAdapter invokes the handler. * DispatcherServlet processes a handler in an execution chain, consisting * of any number of interceptors, with the handler itself at the end. * With this method, each interceptor can decide to abort the execution chain, * typically sending an HTTP error or writing a custom response. * Note: special considerations apply for asynchronous * request processing. For more details see * {@link org.springframework.web.servlet.AsyncHandlerInterceptor}. * The default implementation returns {@code true}. * @param request current HTTP request * @param response current HTTP response * @param handler chosen handler to execute, for type and/or instance evaluation * @return {@code true} if the execution chain should proceed with the * next interceptor or the handler itself. Else, DispatcherServlet assumes * that this interceptor has already dealt with the response itself. * @throws Exception in case of errors */ default boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { return true; } /** * Intercept the execution of a handler. Called after HandlerAdapter actually * invoked the handler, but before the DispatcherServlet renders the view. * Can expose additional model objects to the view via the given ModelAndView. * DispatcherServlet processes a handler in an execution chain, consisting * of any number of interceptors, with the handler itself at the end. * With this method, each interceptor can post-process an execution, * getting applied in inverse order of the execution chain. * Note: special considerations apply for asynchronous * request processing. For more details see * {@link org.springframework.web.servlet.AsyncHandlerInterceptor}. * The default implementation is empty. * @param request current HTTP request * @param response current HTTP response * @param handler handler (or {@link HandlerMethod}) that started asynchronous * execution, for type and/or instance examination * @param modelAndView the {@code ModelAndView} that the handler returned * (can also be {@code null}) * @throws Exception in case of errors */ default void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception { } /** * Callback after completion of request processing, that is, after rendering * the view. Will be called on any outcome of handler execution, thus allows * for proper resource cleanup. * Note: Will only be called if this interceptor's {@code preHandle} * method has successfully completed and returned {@code true}! * As with the {@code postHandle} method, the method will be invoked on each * interceptor in the chain in reverse order, so the first interceptor will be * the last to be invoked. * Note: special considerations apply for asynchronous * request processing. For more details see * {@link org.springframework.web.servlet.AsyncHandlerInterceptor}. * The default implementation is empty. * @param request current HTTP request * @param response current HTTP response * @param handler handler (or {@link HandlerMethod}) that started asynchronous * execution, for type and/or instance examination * @param ex any exception thrown on handler execution, if any; this does not * include exceptions that have been handled through an exception resolver * @throws Exception in case of errors */ default void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception { } } WebRequestInterceptor /* * Copyright 2002-2016 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the \"License\"); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * https://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an \"AS IS\" BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */ package org.springframework.web.context.request; import org.springframework.lang.Nullable; import org.springframework.ui.ModelMap; /** * Interface for general web request interception. Allows for being applied * to Servlet request by building on the {@link WebRequest} abstraction. * * This interface assumes MVC-style request processing: A handler gets executed, * exposes a set of model objects, then a view gets rendered based on that model. * Alternatively, a handler may also process the request completely, with no * view to be rendered. * * In an async processing scenario, the handler may be executed in a separate * thread while the main thread exits without rendering or invoking the * {@code postHandle} and {@code afterCompletion} callbacks. When concurrent * handler execution completes, the request is dispatched back in order to * proceed with rendering the model and all methods of this contract are invoked * again. For further options and comments see * {@code org.springframework.web.context.request.async.AsyncWebRequestInterceptor} * * This interface is deliberately minimalistic to keep the dependencies of * generic request interceptors as minimal as feasible. * * @author Juergen Hoeller * @since 2.0 * @see ServletWebRequest * @see org.springframework.web.servlet.DispatcherServlet * @see org.springframework.web.servlet.handler.AbstractHandlerMapping#setInterceptors * @see org.springframework.web.servlet.HandlerInterceptor */ public interface WebRequestInterceptor { /** * Intercept the execution of a request handler before its invocation. * Allows for preparing context resources (such as a Hibernate Session) * and expose them as request attributes or as thread-local objects. * @param request the current web request * @throws Exception in case of errors */ void preHandle(WebRequest request) throws Exception; /** * Intercept the execution of a request handler after its successful * invocation, right before view rendering (if any). * Allows for modifying context resources after successful handler * execution (for example, flushing a Hibernate Session). * @param request the current web request * @param model the map of model objects that will be exposed to the view * (may be {@code null}). Can be used to analyze the exposed model * and/or to add further model attributes, if desired. * @throws Exception in case of errors */ void postHandle(WebRequest request, @Nullable ModelMap model) throws Exception; /** * Callback after completion of request processing, that is, after rendering * the view. Will be called on any outcome of handler execution, thus allows * for proper resource cleanup. * Note: Will only be called if this interceptor's {@code preHandle} * method has successfully completed! * @param request the current web request * @param ex exception thrown on handler execution, if any * @throws Exception in case of errors */ void afterCompletion(WebRequest request, @Nullable Exception ex) throws Exception; } 方法区别： HandlerInterceptor WebRequestInterceptor boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) void preHandle(WebRequest request) void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) void postHandle(WebRequest request, @Nullable ModelMap model) void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) void afterCompletion(WebRequest request, @Nullable Exception ex) 可以看到preHandler方法的区别。HandlerInterceptor返回boolean，用来判断请求是否可以向下执行。通过注释可以发现HandlerInteceptor和WebRequestInterceptor的preHandler的区别。前者重在执行handler之间的逻辑判断；后者重在对资源的初始化上面。 3.拦截器处理逻辑 首先我们看一下SpringMVC的处理流程。 图1 SpringMVC处理流程 ​ 图片来自头条@黄小斜 SpringMVC具体的执行过程如下： 1.请求通过DispatcherServlet进行路由 2.这个类使用HandlerMapping找到对应的Controller/或者叫Handler preHandle 3.然后再通过HandlerAdapter确定由Controller里面哪个具体的方法执行 4.由上面Controller里面具体方法返回ModelAndView。 postHandle 5.然后由ViewResolver决定选择哪个View/视图 6.然后使用Model渲染这个上面返回的视图 afterCompletion 7.最后返回Response对象 boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) Intercept the execution of a handler. Called after HandlerMapping determined an appropriate handler object, but before HandlerAdapter invokes the handler. DispatcherServlet processes a handler in an execution chain, consisting of any number of interceptors, with the handler itself at the end. With this method, each interceptor can decide to abort the execution chain, typically sending an HTTP error or writing a custom response. Note: special considerations apply for asynchronous request processing. For more details see AsyncHandlerInterceptor. 可以看出preHandler是在HandlerMapping确定了Handler对象之后，调用Handler对象之前，所以在preHandle中可以访问到Handler对象 void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,@Nullable ModelAndView modelAndView) Intercept the execution of a handler. Called after HandlerAdapter actually invoked the handler, but before the DispatcherServlet renders the view. Can expose additional model objects to the view via the given ModelAndView postHandle在调用了Handler之后，渲染视图之前，所以能够访问到ModelAndView对象。 void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,@Nullable Exception ex) Callback after completion of request processing, that is, after rendering the view. Will be called on any outcome of handler execution, thus allows for proper resource cleanup. Note: Will only be called if this interceptor's preHandle method has successfully completed and returned true! As with the postHandle method, the method will be invoked on each interceptor in the chain in reverse order, so the first interceptor will be the last to be invoked. 渲染视图之后，并且只有preHandler返回true才会调用。 上面的结合springMVC处理流程看。 4.多个拦截器处理流程 当存在多个拦截器时，拦截器的处理流程如下： preHandle #1 -> preHandle #2 -> preHandle -> #3 -> Handler postHandle #3 afterCompletion #3 当存在多个拦截器时，preHandle方法按照拦截器的注册顺序 顺序执行，postHandle方法则按照拦截器的注册顺序 逆序执行，afterCompletion方法则按照拦截器的注册顺序 逆序执行。 5.Spring和SpringBoot配置拦截器方式 SpringBoot配置拦截器 1.定义拦截器 图2 定义拦截器 2.注册拦截器 图3 注册拦截器 Spring拦截器注册方式 6.参考资料 https://www.jianshu.com/p/25ea148edbc1 https://www.toutiao.com/a6808139254972023300/ https://www.cnblogs.com/juanzila/p/11276067.html https://www.cnblogs.com/jing99/p/11147152.html https://blog.csdn.net/qq924862077/article/details/53524507 https://www.jianshu.com/p/1e8d088c2be9 https://blog.csdn.net/qq_36918149/article/details/93405589 "},"spring framework/spring-mvc/spring-global-exception/":{"url":"spring framework/spring-mvc/spring-global-exception/","title":"2.2.3 Spring全局统一异常处理","keywords":"","body":"Spring全局统一异常处理 目录： 简介 注册异常处理器 参考资料 1.简介 在实际的web工程开发中，会出现各种类型的异常，通常的做法是使用try-catch将可能出现异常的代码进行处理。然而这样的缺点是，会出现大量的样版式代码，异常处理逻辑和正常业务逻辑相耦合，开发人员不仅要写业务代码，还要考虑业务中可能出现的异常。Spring统一异常处理能解决上面的问题，将正常业务逻辑和异常业务逻辑解耦。其处理方式如下： 图1 Spring异常处理 如图所示，异常类型#1/#2/#3都是业务层可能产生的异常，这些异常经过Spring统一异常处理返回给前端相应的状态码或者Model对象。具体的异常处理逻辑在Spring统一异常处理层做，而不是耦合在业务层。 2.注册异常处理器 2.1 Controller 图2 controller层 2.2 ExceptionHandler 图2 ExceptionHandler ExceptionHandler处理NullPointerException，并且向前端返回状态码 注意：@ControllerAdvice , @ExceptionHandler 3.参考资料 https://www.toutiao.com/a6471246543285387790/ https://www.toutiao.com/a6597726289598087688/ https://www.toutiao.com/a6568045618189566467/ "},"spring framework/spring-mvc/spring-mvc-async-servlet/":{"url":"spring framework/spring-mvc/spring-mvc-async-servlet/","title":"2.2.4 Spring异步处理Servlet","keywords":"","body":"Spring异步处理Servlet 目录: 简介 原理 例子 参考资料 1.简介 通常Servlet的主要工作流程为，客户端发起请求，Servlet接收到请求后进行业务处理，最后将处理结果返回。 sequenceDiagram 客户端->>服务器:第一步：发送请求 服务器->>业务层:第二步：处理业务逻辑 服务器->>客户端:第三步：返回结果 图1 典型Servlet请求 其中，第二步处理业务逻辑通常是最耗时的，主要体现在数据库操作，跨网络调用等。在此过程中，Servlet线程一直处于阻塞状态，直到方法执行完毕。在业务处理过程中，服务器的工作线程数是有限的，Servlet资源(Servlet线程)一直被占用得不到释放，对于并发请求比较大的情况下，其他的请求由于获取不到连接而处于等待状态。这样就影响了服务器的吞吐能力。 2.原理 异步请求的请求类型keep-alive，这样客户端请求后不关闭连接，这样服务器就可以把返回结果推送到客户端。异步请求的过程如下，客户端发起请求，Servlet线程将请求转交给一个异步线程来执行业务处理，线程本身返回到容器(这样这个线程就可以继续处理接下来的请求)，，异步线程处理完业务以后，可以直接生成响应数据（异步线程拥有 ServletRequest 和 ServletResponse 对象的引用），或者将请求继续转发给其它 Servlet。如此一来， Servlet 线程不再是一直处于阻塞状态以等待业务逻辑的处理，而是启动异步线程之后可以立即返回， Servlet request请求线程可以被快速释放回Web容器，从而提高并发性。 sequenceDiagram participant 客户端 participant 服务器线程 participant 服务器回调处理线程 participant 后端处理服务 客户端->>服务器线程:第一步：发送请求 服务器线程->>后端处理服务:第二步：将请求委托给后端处理线程 服务器线程->>服务器线程:第三步：服务器线程返回到线程池 后端处理服务->>服务器回调处理线程:第四步：返回结果 服务器回调处理线程->>客户端:第五步：返回结果到客户端 图2 Servelt异步请求 2.1 Spring异步请求配置 SpringMVC中Controller中的方法返回值为java.util.concurrent.Callable的时候Spring就会自动启动异步执行。Spring返回的Callable对象会被RequestMappingHadnlerAdapter拦截，然后将任务提交到线程池，默认使用SimpleAsyncTaskExecutor去处理，线程池会产生一个新的线程取执行Callable中的代码。SimpleAsyncTaskExecutor每次会产生一个新的线程去处理。 1.设置ThreadPoolTaskExecutor属性 // 核心线程，即使空闲也不会被销毁 // 线程池最大线程数 //缓冲队列大小 //线程池中产生线程名字前缀 //线程池中空闲线程的存活时间，单位秒 2.设置线程池 // 设置超级处理的bean 3.例子 使用linux ab命令进行测试。 1.同步请求 服务器启动 （idea debug模式） 图3 服务器debug模式 如图，可以看到tomcat服务器使用了NIO方式，用http-nio-8080-Acceptor来接收客户端的请求，默认线程池数量为10。可以看到线程目前都是wait状态 ab -n100000 -c20000 http://localhost:8080/async/sync 模拟20000个客户端同时请求，请求总数100000 图2 使用ab命令发送请求 可以看到服务器线程增多，并且线程都处于SLEEPING，MONITOR状态（具体业务代码是线程sleep 1秒）。 2.异步请求 ab -n100000 -c20000 http://localhost:8080/async/async 模拟20000个客户端同时请求，请求总数100000 图3 使用ab命令发送异步请求url 可以看到生成了\"task-1...task-8\"这些线程，而tomcat服务器线程处于wait状态 图5 tomcat NIO Acceptor 图6 接收客户端连接 如图5，6是tomcat服务器等待客户端连接的代码，其实就是使用了典型的NIO编程模型 4.参考资料 https://www.oschina.net/question/1414315_2286431?sort=time https://www.jianshu.com/p/f9e2255ffec2 https://blog.csdn.net/he90227/article/details/52262163 （推荐） https://www.iteye.com/blog/elim-2426566 （推荐） https://www.cnblogs.com/zemliu/p/3556615.html https://blog.csdn.net/it_freshman/article/details/84330461 https://blog.csdn.net/JinXYan/article/details/89340711 "},"spring framework/spring-test/":{"url":"spring framework/spring-test/","title":"2.3 Spring-Test","keywords":"","body":""},"spring framework/spring-test/spring-web-mock-test/":{"url":"spring framework/spring-test/spring-web-mock-test/","title":"2.3.1 Spring-mvc-mock","keywords":"","body":"Spring-mvc mock Test 目录: 简介 maven依赖 测试用例 QA 1.简介 Spring Mock测试框架允许用代码的方式进行http请求，从而测试Spring mvc的controller，service，dao的整个代码。与Postman不一样的是，Postman进行http请求时需要启动服务器。 mock测试指的是在测试环境下生成生产环境下的对象，从而进行测试。例如：在Tomcat服务器中，HttpServletRequest对象是服务器生成，需要启动服务器才能获取这个对象；然而在mock环境下可以mock所需要的HttpServletRequest对象 2.maven依赖 junit junit 4.1.13 org.springframework spring-test 4.1.3.RELEASE 3.测试用例 @Runwith(SpringJunit4ClassRunner.class) // 只有WebMvc项目使用这个注解 @WebApplicationConfiguration // 配置事务管理器，默认回滚事务，保证测试数据库数据完整性 @TransactionConfiguration(transanctionManager=\"txManager\",defaultRollBack=true) @Transactional // spring配置文件位置 @ContextConfiguration(locations={\"classpath:spring.xml\",\"classpath=springmvc.xml\"}) public class SpringMvcTest{ protected MockMvc mock; @Autowired private WebApplicationContext wac; // 设置WebApplicationContext对象 @Before public void setMockMvc(){ mock = MockMvcBuilder.webAppContextSetup(wac).build(); } /** * 测试目标： * 测试数据： * 测试结果： * * */ @Test public void postTest(){ // 构造post请求 mock.perform(MockMvcRequestBuilders.post(\"url\") .contentType(\"application/json\") .content(\"json\")).andDo(print(()); } } 4.QA 注意： 1.项目中配置了拦截器，用于拦截某个特定的用户的登录信息。 这种情况下要在测试代码中首先(@Before)配置好拦截器要拦截的信息，直至请求能够到达Controller层 "},"spring framework/spring-boot/":{"url":"spring framework/spring-boot/","title":"2.4 Spring-Boot","keywords":"","body":" "},"spring framework/spring-boot/spring-boot项目配置/":{"url":"spring framework/spring-boot/spring-boot项目配置/","title":"2.4.1 Spring-boot项目配置","keywords":"","body":"Spring项目配置 目录： 简介 Spring-boot项目结构 Spring-boot配置 特点 总结 参考 1.简介 Spring Boot makes it easy to create stand-alone,production-grade Spring based Applications that you can \"just run\". we take and opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring boot applicaitons need Spring Configuration. 我们在使用Spring Boot时只需要配置相应的Spring Boot就可以用所有的Spring组件，简单的说，spring boot就是整合了很多优秀的框架，不用我们自己手动的去写一堆xml配置然后进行配置。 2.Spring-boot项目结构 图1 Spring-Boot项目结构 图2 Spring Configuration和Component Spring-Boot/Spring项目的两个主要配置就是，配置类/x-config.xml，属性文件。这是Spring项目的重点。 配置类/x-config.xml提供Spring项目运行需要的对象 配置@SpringBootApplication注解相当于配置了@Configuration ,@EnableAutoConfiguration ,@ComponentScan Indicates a configuration class that declares one or more @Bean methods and also triggers auto-configuration and component scanning .This is a convenience annotation that is equivalent to declaring @Configuration, @EnableAutoConfiguration and @ComponentScan. 3.Spring-boot配置 1.maven配置 org.springframework.boot spring-boot-starter-web org.springframework.boot spring-boot-starter-logging org.springframework.boot spring-boot-starter-tomcat org.springframework.boot spring-boot-starter-test test org.springframework.boot spring-boot-starter-log4j2 1.5.8.RELEASE org.springframework.boot spring-boot-starter-tomcat provided org.mybatis.spring.boot mybatis-spring-boot-starter 2.0.0 2.SpringBootDemoApplication配置 SpringBoot项目作为一个annotation-driven的项目，配置大都是依赖注解 @SpringBootApplication @EnableAsync @EnableTransactionaManageMent @EnableAspectJAutoProxy(proxyTargetClass = true, exposeProxy = true) @PropertySources(value = { @PropertySource(value = {\"classpath:config/common.properties\"}, ignoreResourceNotFound = true, encoding = \"utf-8\")}) @Import(SpringConfiguration.class) public class SpringBootDemoApplication { public static void main(String[] args) { SpringApplication.run(SpringBootDemoApplication.class, args); } } 3.SpringBoot项目集成MyBatis 引入依赖 org.mybatis mybatis 3.5.4 org.mybatis.spring.boot mybatis-spring-boot-starter 2.0.0 项目结构 图3 SpringBoot继承Mybatis app.properties里面添加mybatis.mapper-locations=classpath:mapper/*.xml。MyBatisMapper接口上面使用@Mapper注解 4.特点 Create stand-alone Spring applications 快速创建独立运行的Spring项目 Embed Tomcat, Jetty or Undertow directly (no need to deploy WAR files) 内嵌Tomcat，应用无需打成WAR包 Provide opinionated 'starter' dependencies to simplify your build configuration starters自动依赖简化配置 Automatically configure Spring and 3rd party libraries whenever possible 自动配置Spring和第三方库 Provide production-ready features such as metrics, health checks, and externalized configuration 准生产环境的运行时应用监控 Absolutely no code generation and no requirement for XML configuration 无代码生成和XML配置 5.总结 学会创建Spring-Boot项目 了解Spring-Boot项目结构 了解Spring-Boot配置 6.参考 https://baijiahao.baidu.com/s?id=1623648034778672046&wfr=spider&for=pc https://baijiahao.baidu.com/s?id=1638998808858231030&wfr=spider&for=pc https://blog.csdn.net/qq_31142237/article/details/89326765 https://blog.csdn.net/qq_19167629/article/details/90899232 "},"spring framework/spring-data/":{"url":"spring framework/spring-data/","title":"2.5 Spring-Data","keywords":"","body":""},"spring framework/spring-cloud/":{"url":"spring framework/spring-cloud/","title":"2.6 Spring-Cloud","keywords":"","body":""},"spring framework/spring-rest/":{"url":"spring framework/spring-rest/","title":"2.7 Spring-Rest","keywords":"","body":""},"spring framework/spring-util/":{"url":"spring framework/spring-util/","title":"2.8 Spring-Util","keywords":"","body":""},"spring framework/spring-util/spring-cron/":{"url":"spring framework/spring-util/spring-cron/","title":"2.8.1 Spring定时任务和Cron表达式","keywords":"","body":"Spring定时任务和Cron表达式 目录： 简介 Cron表达式 Spring定时任务配置 QA 参考资料 1.简介 Spring定时任务框架根据cron表达式对任务进行定时调度。本节主要内容是Cron表达式和Spring定时任务的配置 2.Cron表达式 Cron表达式是用来配置Spring定时任务执行时间的时间串，由5个空格分隔成的6个域构成，格式如下 {秒/seconde} {分/minutes} {时/hour} {日/dayofmonth} {月/month} {周/dayofweek} 每一个域含义解释： 1)秒：表示在指定的秒数触发定时任务，范围0-59。例如，\"*\"表示任何秒都触发，\"0,3\"表示0秒和3秒触发。 2)分：表示在指定的分钟触发定时任务，范围0-59。例如，\"0-3\"表示0分钟到3分钟每分钟都触发，\"0/2\"表示只有偶数分钟触发。 3)时：表示在指定的小时触发定时任务，范围0-23。例如，\"3-15/2\"表示上午3点到下午3点每隔2个小时触发。 4)日：表示在指定的日期触发定时任务，范围1-31(可以写0，但不会生效)。例如，\"1\"表示1号触发，\"5,15\"表示5号和15号触发。需要注意的是，日期可以写0，不会报错但也不会生效。 5)月：表示在指定的月份触发定时任务，范围1-12。例如，\"1-4,12\"表示1月到4月以及12月触发。 6)周：表示在指定的星期触发定时任务，范围0-7(0和7都表示周日)。例如，\"?\"表示一周都触发，\"6,7\"表示周六日触发。 注意，1月到12月可以用对应的英文缩写JAN-DEC代替，周日到周六可以用对应的英文缩写SUN-SAT代替。但是，周日的缩写SUN只会被替换为0，因此在cron表达式的周域，我们可以写6-7，却不能写SAT-SUN。 特殊符号： （1) ：表示匹配该域的任意值。假如在Minutes域使用, 即表示每分钟都会触发事件。 （2）?：只能用在DayofMonth和DayofWeek两个域。它也匹配域的任意值，但实际不会。因为DayofMonth和DayofWeek会相互影响。例如想在每月的20日触发调度，不管20日到底是星期几，则只能使用如下写法： 13 13 15 20 ?, 其中最后一位只能用？，而不能使用\\，如果使用*表示不管星期几都会触发，实际上并不是这样。 （3）- ：表示范围。例如在Minutes域使用5-20，表示从5分到20分钟每分钟触发一次 （4）/ ：表示起始时间开始触发，然后每隔固定时间触发一次。例如在Minutes域使用5/20,则意味着5分钟触发一次，而25，45等分别触发一次. （5）, ：表示列出枚举值。例如：在Minutes域使用5,20，则意味着在5和20分每分钟触发一次。 例子： （1）0 0 2 1 * ? * 表示在每月的1日的凌晨2点调整任务 （2）0 15 10 ? * MON-FRI 表示周一到周五每天上午10:15执行作业 （3）0 15 10 ? 6L 2002-2006 表示2002-2006年的每个月的最后一个星期五上午10:15执行作 （4）0 0 10,14,16 * * ? 每天上午10点，下午2点，4点 （5）0 0/30 9-17 * * ? 朝九晚五工作时间内每半小时 （6）0 0 12 ? * WED 表示每个星期三中午12点 （7）0 0 12 * * ? 每天中午12点触发 （8）0 15 10 ? * * 每天上午10:15触发 （9）0 15 10 * * ? 每天上午10:15触发 （10）0 15 10 * * ? 每天上午10:15触发 （11）0 15 10 * * ? 2005 2005年的每天上午10:15触发 （12）0 * 14 * * ? 在每天下午2点到下午2:59期间的每1分钟触发 （13）0 0/5 14 * * ? 在每天下午2点到下午2:55期间的每5分钟触发 （14）0 0/5 14,18 * * ? 在每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 （15）0 0-5 14 * * ? 在每天下午2点到下午2:05期间的每1分钟触发 （16）0 10,44 14 ? 3 WED 每年三月的星期三的下午2:10和2:44触发 （17）0 15 10 ? * MON-FRI 周一至周五的上午10:15触发 总结： ​ 1.注意cron特殊符号的用法 ​ 2.注意cron表达式“每天”的写法，0 15 10 ? 或 0 15 0 ? 3.如果指定日期，dayofweek要用? ，例如： 0 15 10 10 * ? ，即每月10号上午10点15分执行 3.Spring定时任务配置 3.1 Springboot配置 1.启用@EnableScheduling注解 图1 启用@EnableScheduling 其中@EnableScheduling可以在配置类@Compnent也可以在Springboot启动类SpringApplicaitonUtil @EnableScheduling This enables detection of @Scheduled annotations on any Spring-managed bean in the container. 2.创建任务类，执行任务使用 @Scheduled注解 例子： method #1: package com.myco.tasks; public class MyTask{ @Scheduled(fixedRate=1000) public void work(){ // task execution logic } } the following configuration would ensure that MyTask.work() is called once every 1000 ms: @Configuration @EnableScheduling public class AppConfig { @Bean public MyTask task() { return new MyTask(); } } method #2: use ComponentScan: @Configuration @EnableScheduling @ComponentScan(basePackages=\"com.myco.tasks\") public class AppConfig { } method #3: Methods annotated with @Scheduled may even be declared directly within @Configuration classes: @Configuration @EnableScheduling public class AppConfig { @Scheduled(fixedRate=1000) public void work() { // task execution logic } } 3.配置执行器(TaskScheduler) By default, will be searching for an associated scheduler definition: either a unique org.springframework.scheduling.TaskScheduler bean in the context, or a TaskScheduler bean named \"taskScheduler\" otherwise; the same lookup will also be performed for a java.util.concurrent.ScheduledExecutorService bean. If neither of the two is resolvable, a local single-threaded default scheduler will be created and used within the registrar. 默认情况下Spring会搜索org.springframework.scheduling.TaskScheduler类型的bean或者名称为taskScheduler的bean，同样也会搜索java.util.concurrent.ScheduledExecutorService类型的bean；如果都没有搜索到，spring会创建一个single-thread scheduler 通过实现SchedulerConfigurer配置执行器 @Configuration @EnableScheduling public class AppConfig implements SchedulingConfigurer { @Override public void configureTasks(ScheduledTaskRegistrar taskRegistrar) { taskRegistrar.setScheduler(taskExecutor()); } @Bean(destroyMethod=\"shutdown\") public Executor taskExecutor() { return Executors.newScheduledThreadPool(100); } } 3.2 Spring xml配置 4.QA 5.参考资料 https://www.cnblogs.com/javahr/p/8318728.html https://www.cnblogs.com/summary-2017/p/8974139.html "},"linux/":{"url":"linux/","title":"3.Linux","keywords":"","body":""},"linux/shell/":{"url":"linux/shell/","title":"3.1 Shell","keywords":"","body":""},"database/":{"url":"database/","title":"4.DataBase","keywords":"","body":""},"database/mysql/":{"url":"database/mysql/","title":"4.1 MySQL","keywords":"","body":""},"database/mysql/sql/":{"url":"database/mysql/sql/","title":"4.1.1 SQL","keywords":"","body":""},"database/mysql/transaction/":{"url":"database/mysql/transaction/","title":"4.1.2 Transaction","keywords":"","body":"MySQL事务特点和四种隔离特性 目录: 简介 事务特性 事务隔离级别 事务提交 参考资料 1.简介 一个事务涉及到大量的CPU操作和IO操作,这些操作被打包成一个执行单元,要么同时完成,要么同时不完成.事务是一组原子性SQL命令或者说一个独立的工作单元,如果数据库引擎能够成功对数据库应用该组的全部SQL语句.那么就执行该组命令.如果其中任何一条语句因为崩溃或者其它原因无法执行,那么该组所有的SQL语句都无法执行. 可以这么理解事务.事务是一组TO DO LIST ,事务的每个操作都是TO DO LIST里面的一个ITEM项. -------TO DO LIST-------- #1.item1 #2.item2 #3.item3 .... -------TO DO LIST END--- 事务的具体执行做法就是,逐个执行ITEM( one by one ).如果其中某个ITEM出错则回滚(rollback). 2.事务特性 原子性 一个事务中的所有操作,要么都完成,要么都不执行.对于一个事务来说,不能只执行其中的一部分. 图1 事务原子性 上图这个圆圈代表事务的原子性,一个不被打破的执行单元. 一致性 数据库总是从一个一致性状态转到另外一个一执行状态. 这个一执行状态怎么解释:银行账户300元(一致性状态),然后进行转出操作20元,那么目前银行帐户280(一致性转台) 隔离性 一个事务所做的修改在事务的最终提交之前,对其它事务是不可见的.多个事务之间的操作相互不影响,每降低一个事务隔离个别都能够提高数据库的并发. 持久性 一旦一个事务提交了,就算服务器崩溃,让要在下次启动的时候自动恢复. 结合事务日志完成: ​ 事务日志写入磁盘的时候是顺序IO,写数据文件的时候是随机IO(数据地址不确定).一旦事务提交了,必须立即执行一个IO操作,确保此事务立即写入磁盘. 事务的状态: ​ 活动(active) -----> 中止(pause/inactive)------> 活动 ------> 失败(failed) -------> 部分提交 -----> 提交 3.事务隔离级别 read uncommited (读未提交事务) read commited (读已提交事务) reputable read(可重复读) serializable(可串行化) 脏读(dirty read): 读取到了其它事务未提交的内容 不可重复读(Nonrepetable read): 在同一个事务中,完全相同的select语句可能看到不一样的结果( so wired -_-!). 造成这样的结果可能原因: ​ (1) 有一个交叉的事务有新的commit,导致了数据的改变 ​ (2) 一个数据库被多个实例操作时,同一事务的其它实例在该实例处理期间可能有新的commit 幻影读(phantom read): 读取某一个范围数据行的时候,另一个事务在该范围内插入了新行,当再一次读区这个范围的数据行时,会发现新的“幻影”行. 我个人称之为“眩晕读(duzzy read)”,因为这个感觉就像眼冒金星一样.第二次看到了新的东西(幻影行) 读未提交事务- read uncommited (1)所有事务都可以看到其它事务未提交的执行结果 -------TMD不乱了套了吗 (2)存在问题: 脏读,不可重复读,幻读 执行顺序: 1.select * from tx ; # 事务1 id num 1 1 2 2 3 3 2.update tx set num=10 where id=1 # 事务2 id num 1 10 2 2 3 3 3.select * from tx; #事务1 id num 1 10 2 2 3 3 可以看到事务1读到了事务2未提交的数据 读已提交事务- read commited (1)一个事务只能看见已提交事务所做的改变 (2)存在不可重复读的问题 执行顺序: 1.select * from tx; #事务1 id num 1 1 2 2 3 3 2.update tx set num=10 where id=1(不提交) #事务2 3.select * from tx; #事务1 id num 1 1 2 2 3 3 因为事务2没有提交,所以事务2做的改变事务1看不见 可重复读 - read repeatable (1)解决不可重复读 (2)问题:幻影读 隔离级别 脏读 不可重复读 幻读 读未提交 y y y 读已提交 x y y 可重复读 x x y 串行化 x x x 4.事务提交 如果没有显式启动事务,数据库会根据autocommit的值,默认每条sql都会自动提交 事务日志 事务要保证ACID完成性必须依靠事务日志跟踪,每一个操作在真正写入数据库之前,先写入到日志文件中.如果要删除一行数据会现在日志文件中将此行标记为删除,但是数据库中的文件并没有发生变化.只有在整个事务提交后,再把整个事务的sql语句批量同步到磁盘上的数据库文件. 5.参考资料 https://www.cnblogs.com/xrq730/p/5087378.html https://www.cnblogs.com/devilwind/p/8058268.html https://www.cnblogs.com/snsdzjlz320/p/5761387.html https://www.cnblogs.com/zl0372/articles/mysql_16.html https://www.cnblogs.com/yxh168/p/9174932.html https://blog.csdn.net/weixin_43639512/article/details/84304672 "},"database/redis/":{"url":"database/redis/","title":"4.2 Redis","keywords":"","body":""},"database/mybatis/":{"url":"database/mybatis/","title":"4.3 MyBatis","keywords":"","body":""},"database/mybatis/mybatis参数绑定/":{"url":"database/mybatis/mybatis参数绑定/","title":"4.3.1 MyBatis参数绑定方式","keywords":"","body":"MyBatis参数绑定方式 目录： 简介 XML参数绑定方式 注解参数绑定方式 总结 参考 1.简介 本文主要记录MyBatis使用XML文件和注解进行参数绑定的两种方式，以及在开发过程中遇到的一些MyBatis语法上面遇见的问题 2.XML参数绑定方式 XML参数绑定方式 public interface UserMapperDAO{ //单参数绑定 User selectOne(@Param(\"id\")Long id); //多参数绑定 User selectTne(@Parm(\"id\")Long id,@Param(\"name\")String name); //传入对象 User selectThree(@Param(\"vo\")UserQueryVo vo) } 参数名称传递 .... select * from User where auto_pk = #{id} select * from User where auto_pk = #{id} and name=#{name} select * from User where auto_pk = #{vo.id} and name= #{vo.name} 索引值传递 Mapper接口方法参数从左到右从0开始 .... select * from User where auto_pk = #{0} select * from User where auto_pk = #{0} and name=#{1} select * from User where auto_pk = #{vo.id} and name= #{vo.name} 3.注解参数绑定方式 public interface UserMapperDAO{ //单参数绑定 @Select(\"select * from User where id=#{id}\") User selectOne(@Param(\"id\")Long id); //多参数绑定 @Select(\"select * from User where id=#{id} and name=#{name}\") User selectTne(@Parm(\"id\")Long id,@Param(\"name\")String name); //传入对象 @Select(\"select * from User where id=#{vo.id} and name=#{vo.name}\") //或者 @SelectProvider(type=UserMapperDAOProvider.calss , method=\"selectThree\") User selectThree(@Param(\"vo\")UserQueryVo vo) // 要继承SqlBuilder public static UserMapperDAOProvider extends SqlBuilder{ /** * 返回值：string 即生成的sql语句 * 参数：mybatis会把接口中的注解-对应的值变成map的形式 */ public String selectThree(Map params){ UserQueryVo vo = (UserQueryVo) params.get(\"vo\"); BEGIN(); SELECT(\"*\"); FROM(\"User\"); //注意：使用vo对象里面的属性时必须用下面的方式 WHERE(\"id=#{vo.id}\"); //WHERE(\"id=\" + vo.getId()) ❌错误写法，实际工程实验中会出错 return SQL(); } } } 4.总结 了解MyBatis配置的两种方式XML，注解 了解MyBatis参数绑定的方式：索引值，对象，注解 在Provider中的动态sql中，如果引用对象的值，不要使用WHERE(\"id=\" + vo.getId())，而是使用WHERE(\"id=#{vo.id}\")的方式。而使用vo.getId()是用来进行java逻辑的判断。 MyBatis动态sql的string类型判空: 5.参考 https://www.cnblogs.com/suhaha/p/11794450.html https://blog.csdn.net/u010159380/article/details/82255461 https://blog.csdn.net/qq_21046965/article/details/84993996 "},"database/mybatis/mybatis迭代/":{"url":"database/mybatis/mybatis迭代/","title":"4.3.2 MyBatis迭代器几种写法","keywords":"","body":"MyBatis迭代器 目录： [简介][1] [MyBatis迭代的几种方式][2] [总结][3] [参考资料][4] 1.简介 MyBatis迭代器用于设置SQL中in的条件。即: select * from User where pk in (...)中in的条件。MyBatis中的迭代器格式如下： \" index=\"index\" open=\"(\" separator=\",\" close=\")\"> #{item} collection : 用于迭代的集合名字 index：集合中的元素 index：迭代时的当前元素位置 open：开始符号 separator : 分隔符 close : 结束符号 2.MyBatis迭代的几种方式 参数：java.util.Collection 集合类型 public List getUserByIds(List id); select * from User where pk in #{item} 参数： 数组类型 public List getUserByIds(String[] id); select * from User where pk in #{item} 参数：多个 这种情况下使用Map,将集合以key-value的格式放到Map中，然后在xml中获取名字即可。实际上MyBatis就是将接口中的参数以名字(@Param(\"\"))和其对应的值放到Map中的，所以可以在xml/SelectProvider从Map中获取参数值从而达到动态SQL。 Map map = Maps.newHashMap(\"ids\",Lists.newArrayList()); public void addUser(Map select * from User where pk in #{item} 3.总结 MyBatis对参数的包装使用Map ，其中key为Mybatis的参数名称，value为参数具体值。 这个思想很重要。 例如： @SelectProvider(type=MyProvider.class,method=\"insertUser\") public void addUser(@Param(\"ids\") List ids, @Param(\"name\")String name, @Param(\"age\") int age); 其中addUser的方法参数会被包装为Map：{\"ids\":[] , \"name的值\": \"\" , \"age\": \"age的值\"}。 在SelectProvider中可以获得参数 public class MyProvider extends SQLBuilder{ public String insertUser(Map params){ BEGIN(); String name =(String) params.get(\"name\"); int age = (int)params.get(\"age\"); // 根据业务逻辑拼装SQL return SQL(); } } 3.参考资料 https://blog.csdn.net/zuihongyan518/article/details/86478222 https://www.cnblogs.com/yy3b2007com/p/10417242.html#autoid-0-0-0 https://www.bbsmax.com/A/QV5ZGEa7dy/ "},"network/":{"url":"network/","title":"5.Network","keywords":"","body":""},"network/http/":{"url":"network/http/","title":"5.1 Http","keywords":"","body":""},"network/tcp/":{"url":"network/tcp/","title":"5.2 TCP","keywords":"","body":""},"operation_system/":{"url":"operation_system/","title":"6.Operation System","keywords":"","body":""},"operation_system/file_sequence_random_io/":{"url":"operation_system/file_sequence_random_io/","title":"6.1 文件顺序/随机IO","keywords":"","body":"文件顺序/随机IO 目录： 磁盘的组成结构 磁盘读取响应时间 块/簇/页 IO读取模型 顺序/随机IO 参考资料 1.磁盘的组成结构 图1 磁盘组成结构 如图所示，磁盘由以下几部分组成：盘片（platter）,磁头（head），磁道（track）,扇区（sector）， 柱面（cydiner）组成 图2 盘片组成 上图显示的是一个盘面，盘面中一圈圈灰色同心圆为一条条磁道，从圆心向外画直线，可以将磁道划分为若干个弧段，每个磁道上一个弧段被称之为一个扇区（图践绿色部分）。扇区是磁盘的最小组成单元，通常是512字节。（由于不断提高磁盘的大小，部分厂商设定每个扇区的大小是4096字节) 图3 柱面 硬盘通常由重叠的一组盘片构成，每个盘面都被划分为数目相等的磁道，并从外缘的“0”开始编号，具有相同编号的磁道形成一个圆柱，称之为磁盘的柱面。磁盘的柱面数与一个盘面上的磁道数是相等的。由于每个盘面都有自己的磁头，因此，盘面数等于总的磁头数。 2.磁盘读取响应时间 磁盘读取数据步骤如下 * 寻道时间：将磁头移动到对应的磁道,寻道时间越短，I/O操作越快，目前磁盘的平均寻道时间一般在3－15ms，一般都在10ms左右。 * 旋转延迟：盘片旋转将请求数据所在扇区移至读写磁头下方所需要的时间，旋转延迟取决于磁盘转速。普通硬盘一般都是7200rpm，慢的5400rpm。 * 数据传输：完成传输所请求的数据所需要的时间 其中影响磁盘数据传输效率的主要是：磁盘寻道时间，旋转延迟 注意：按照上文所说应该是每一个盘面只有一个磁头，然后磁盘寻址的时候把磁头移动道相应的磁道。这样是我个人觉得效率太低，每次寻道都要将磁头移动道对应的磁道。可以这样改进，每个磁道都有一个固定磁头，然后选择读取对应的磁头由相应的机械电路控制。这样省去了磁盘的寻道时间 3.块/簇/页 磁盘块/簇（虚拟出来的）。 块是操作系统中最小的逻辑存储单位。操作系统与磁盘打交道的最小单位是磁盘块。 通俗的来讲，在Windows下如NTFS等文件系统中叫做簇；在Linux下如Ext4等文件系统中叫做块（block）。每个簇或者块可以包括2、4、8、16、32、64…2的n次方个扇区。 为什么存在磁盘块？ 读取方便：由于扇区的数量比较小，数目众多在寻址时比较困难，所以操作系统就将相邻的扇区组合在一起，形成一个块，再对块进行整体的操作。 分离对底层的依赖：操作系统忽略对底层物理存储结构的设计。通过虚拟出来磁盘块的概念，在系统中认为块是最小的单位 操作系统经常与内存和硬盘这两种存储设备进行通信，类似于“块”的概念，都需要一种虚拟的基本单位。所以，与内存操作，是虚拟一个页的概念来作为最小单位。与硬盘打交道，就是以块为最小单位。 扇区： 硬盘的最小读写单元 块/簇： 是操作系统针对硬盘读写的最小单元 page： 是内存与操作系统之间操作的最小单元。 扇区 4.IO读取模型 IO操作通常分为两个部分：用户进行空间内核空间 ,内核空间设备空间 LINUX中进程无法直接操作I/O设备，其必须通过系统调用请求kernel来协助完成I/O动作；内核会为每个I/O设备维护一个缓冲区。 对于一个输入操作来说，进程IO系统调用后，内核会先看缓冲区中有没有相应的缓存数据，没有的话再到设备中读取，因为设备IO一般速度较慢，需要等待；内核缓冲区有数据则直接复制到进程空间。 所以，对于一个网络输入操作通常包括两个不同阶段： （1）等待网络数据到达网卡→读取到内核缓冲区，数据准备好； （2）从内核缓冲区复制数据到进程空间。 5.顺序/随机IO 顺序与随机指的是每次数据存取请求对应的地址是否连续。Windows系统采取“见缝插针”的策略进行数据写入，多任务系统下各进程对硬盘位置的读写请求也变得更为随机化。 磁盘读写最慢的地方在于寻道，根据kafka官网写的资料是，寻道时间大概10ms，寻道之后磁头顺序读取信息的速度是很快的，根据kafka官网的说法，6个7200转的磁盘组成raid5，顺序写的速度能达到（600MB/S），而随机读写速度仅为100kb/s。 顺序IO针对大文件拷贝、视频编辑等的任务，读写的过程中会遵循先后顺序，数值越高代表读写性能越强，单位是MB/s。 随机读写速度的单位是IOPS，就是每秒进行的IO操作次数，可以理解为吞吐量指标，数值越高读写性能越强。随机读写也可以从字面意思理解，无疑不遵循文件的先后顺序，当固态硬盘读写操作的时候能够任意跳到某个文件，或者同一文件的某个位置，主要作用是针对零碎文件（病毒扫描、启动程序等）任务。 注意： 顺序/随机IO 的使用场景 顺序/随机IO 的读写文件最主要的区别 顺序/随机IO 单位 MB/S, IOPS 6.参考资料 https://www.toutiao.com/a6771311045630755341/ https://www.toutiao.com/a6761254830716486157/ (推荐) https://www.toutiao.com/a6736053525266039304/ "},"data structure/":{"url":"data structure/","title":"7.Data Structure","keywords":"","body":"数据结构 第一章 "},"algorithm/":{"url":"algorithm/","title":"8.Algorithm","keywords":"","body":""},"math/":{"url":"math/","title":"9.Math","keywords":"","body":""},"programming language/":{"url":"programming language/","title":"10.Programming Language","keywords":"","body":""},"big_data/":{"url":"big_data/","title":"11. 大数据","keywords":"","body":"大数据 "},"big_data/distrubuted_system/":{"url":"big_data/distrubuted_system/","title":"11.1 分布式系统概述","keywords":"","body":"分布式系统概述 目录： 概述 分布式系统特点 数据分布 一致性协议 负载均衡 复制 Paxos协议 参考资料 这篇文章的重要性，描绘了分布式系统涉及到的所有点。了解了这些东西的时候，对于其它分布式系统也就涉及到这些问题。 1.概述 目前随着业务规模不断增加，业务越来越复杂，传统的单机部署越来越不能满足需求。分布式系统(distributed system)成为当前主流的架构。分布式系统从底层的数据存储，中间的业务服务，再到系统的部署，每一部分都涉及到很多技术。 大规模的分布式系统的重要目标就是节省成本，因而只能采用性价比较高PC服务器。这些服务性能很好，但是故障率很高，要求系统在软件层面进行自动容错。当系统节点出现故障时，系统能够自动检测出来，并能将原有的数据和服务迁移到集群中其它正在工作的节点。 分布式系统有两个重要的协议，Paxos选举协议和2PC(两阶段提交协议)。Paxos协议用于多个节点之间达成一致，往往用于节点选举。2PC协议用来保证跨多个节点之间的原子性，这些操作要么全部成功，要么全部失败。这两个协议是理解分布式系统的两个重要协议，其中Paxos协议用来找到集群中的leader，然后2PC协议用来协调集群中节点间的行为，保持节点间行为的一致。 2.分布式系统特点 分布式系统面临的第一个问题就是数据分布，即将数据均匀地分布到多个存储节点。另外为了保证系统的可用性，可靠性，需要将数据复制多个副本，然后分散到多个节点上面，这就带来了副本之间数据一致性问题。 可用性：系统是否可用，别宕机 可靠性：系统能用的同时，提供的服务都是可靠的 分布式系统中，往往将一台服务器或者一台服务器上面的一个进程称之为一个节点，直接之间通过网络连接(rpc,http)。大规模的分布式系统一个核心问题在于自动容错。这里面面临的问题有两大类： 服务器故障 网络问题 服务器故障： 1.服务器宕机 引发服务器宕机的原因可能是内存错误、服务器停电等。服务器宕机可能随时发生，当发生宕机时，节点无法正常工作，称为“不可用”（unavailable）。服务器重启后，节点将失去所有的内存信息。因此，设计存储系统时需要考虑如何通过读取持久化介质（如机械硬盘，固态硬盘）中的数据来恢复内存信息，从而恢复到宕机前的某个一致的状态。进程运行过程中也可能随时因为core dump等原因退出，和服务器宕机一样，进程重启后也需要恢复内存信息。 这一点太重要了，假如说一个已经提交的事务，改动信息目前存放在内存，没有回写到磁盘。这个时候出现宕机，数据库就是不一致的，系统重启时需要根据日志恢复到某个一致的状态。 下图是我本人画的一个图，说明了说明了数据库怎么使用日志来进行宕机恢复后的一致性状态 图1 数据库日志系统 如上图所示，是我本人画的一个数据库日志系统。可能和MYSQL的日志系统不一样，能达到说明问题即可。上图由虚线分为两个部分Memory和Disk，其中Memory中有 Operate Log ，Commited Changes，Uncommited Changes 。Operate Log主要记录客户端的操作，Uncommited Changes 用来保存未提交的改动，Commited Changes用来保存已经提交但未写到磁盘的改动。 Disk中有Log，REDO Log，TODO Log，Changes Block，其中Log记录数据都已经做了哪些操作，这些日志中的操作和数据库的状态是一致的，即Log中保存的操作数据库已经保存了改动。REDO Log和TODO Log 分别与内存中 Commited Change 和Uncommited Changes相对应，分别保存未提交的操作，和已提交的操作；而Changes Block 则是Uncommited Changes在内存中的镜像，改动两者是同步的。 图中有三条线，分别是Uncommited ，Commited , CheckPoint. UnCommited 首先把改动写到Operate Log和TODO Log中，然后载入与改动相关的Block块，首先从Commited Changes找数据块是否已经载入，如果没有则从Disk载入，然后对其进行修改，并把相关改动与Changes Block同步。 Commited 首先将Operate Log中相关日志标记为已提交，然后将TODO Log中的日志信息移动到REDO Log中；之后把Uncommited Changes中的改动放到Commited Changes 中，然后删除Uncommited Changes 和Changes Block 中相应的数据 CheckPoint CheckPoint指的是在当前这个时间点，之前的改动都已经落到磁盘上，是可信的。首先把REDO Log里面的日志信息添加到Log中，然后将Commited Changes中的内容Flush到数据库，最后清除Comminted Changes中相应的数据。 宕机恢复 使用TODO Log ,REDO Log , Changes Block来恢复，将数据库恢复到当机前的状态。首先先把TODO Log , REDO Log , Changes Block都加载到内存，然后重做REDO Log里面的操作，注意：这个时候其实可以不需要undo UNDO log表中的操作，设想这样一个场景，客户端把X=5 update 6,但是未提交，这个时候数据库宕机；客户端不能提交，数据库恢复的时候，由于已经记录了X的改动信息，客户端不需要再进行一遍update操作，只需要提交即可。 2.磁盘故障 磁盘故障是一种发生概率很高的异常。磁盘故障分为两种情况：磁盘损坏和磁盘数据错误。磁盘损坏时，将会丢失存储在上面的数据，因而，分布式存储系统需要考虑将数据存储到多台服务器，即使其中一台服务器磁盘出现故障，也能从其他服务器上恢复数据。对于磁盘数据错误，往往可以采用校验和（checksum）机制来解决，这样的机制既可以在操作系统层面实现，又可以在上层的分布式存储系统层面实现。 网络问题： 1.网络切割 引发网络异常的原因可能是消息丢失、消息乱序（如采用UDP方式通信）或者网络包数据错误。有一种特殊的网络异常称为“网络分区”(network partition)，即集群的所有节点被划分为多个区域，每个区域内部可以正常通信，但是区域之间无法通信。例如，某分布式系统部署在两个数据中心，由于网络调整，导致数据中心之间无法通信，但是，数据中心内部可以正常通信。 设计容错系统的一个基本原则是：网络永远是不可靠的，任何一个消息只有收到对方的回复后才可以认为发送成功，系统设计时总是假设网络将会出现异常并采取相应的处理措施。 2.超时 由于网络异常的存在，分布式存储系统中请求结果存在“三态”的概念。在单机系统中，只要服务器没有发生异常，每个函数的执行结果是确定的，要么成功，要么失败。然而，在分布式系统中，如果某个节点向另外一个节点发起RPC（Remote Procedure Call）调用，这个RPC执行的结果有三种状态：“成功”、“失败”、“超时”（未知状态），也称为分布式存储系统的三态。 图2给出了RPC执行成功但超时的例子。服务器（Server）收到并成功处理完成客户端（Client）的请求，但是由于网络异常或者服务器宕机，客户端没有收到服务器端的回复。此时，RPC的执行结果为超时，客户端不能简单地认为服务器端处理失败 图2 RPC调用超时 当出现超时状态时，只能通过不断读取之前操作的状态来验证RPC操作是否成功。当然，设计分布式存储系统时可以将操作设计为“幂等”的，也就是说，操作执行一次与执行多次的结果相同，例如，覆盖写就是一种常见的幂等操作。如果采用这种设计，当出现失败和超时时，都可以采用相同的处理方式，即一直重试直到成功。 3.数据分布 分布式系统区别于传统单机系统在于能够将数据分布到多个节点，并在多个节点之间实现负载均衡。数据分布的方式主要有两种，一种是哈希分布，如一致性哈希，代表系统为Amazon的Dynamo系统；另外一种方法是顺序分布，即每张表格上的数据按照主键整体有序，代表系统为Google的Bigtable系统。Bigtable将一张大表根据主键切分为有序的范围，每个有序范围是一个子表。 将数据分散到多台机器后，需要尽量保证多台机器之间的负载是比较均衡的。衡量机器负载涉及的因素很多，如机器Load值，CPU，内存，磁盘以及网络等资源使用情况，读写请求数及请求量，等等，分布式存储系统需要能够自动识别负载高的节点，当某台机器的负载较高时，将它服务的部分数据迁移到其他机器，实现自动负载均衡。 分布式存储系统的一个基本要求就是透明性，包括数据分布透明性，数据迁移透明性，数据复制透明性，故障处理透明性。本节介绍数据分布以及数据迁移相关的基础知识。 哈希-一致性哈希 哈希取模的方法很常见，其方法是根据数据的某一种特征计算哈希值，并将哈希值与集群中的服务器建立映射关系，从而将不同哈希值的数据分布到不同的服务器上。所谓数据特征可以是key-value系统中的主键（key），也可以是其他与业务逻辑相关的值。例如，将集群中的服务器按0到N-1编号（N为服务器的数量），根据数据的主键（hash（key）%N）或者数据所属的用户id（hash（user_id）%N）计算哈希值，来决定将数据映射到哪一台服务器。 如果哈希函数的散列特性很好，哈希方式可以将数据比较均匀地分布到集群中去。而且，哈希方式需要记录的元信息也非常简单，每个节点只需要知道哈希函数的计算方式以及模的服务器的个数就可以计算出处理的数据应该属于哪台机器。然而，找出一个散列特性很好的哈希函数是很难的。这是因为，如果按照主键散列，那么同一个用户id下的数据可能被分散到多台服务器，这会使得一次操作同一个用户id下的多条记录变得困难；如果按照用户id散列，容易出现“数据倾斜”（data skew）问题，即某些大用户的数据量很大，无论集群的规模有多大，这些用户始终由一台服务器处理。 传统的哈希分布算法还有一个问题：当服务器上线或者下线时，N值发生变化，数据映射完全被打乱，几乎所有的数据都需要重新分布，这将带来大量的数据迁移。 一种思路是不再简单地将哈希值和服务器个数做除法取模映射，而是将哈希值与服务器的对应关系作为元数据，交给专门的元数据服务器来管理。访问数据时，首先计算哈希值，再查询元数据服务器，获得该哈希值对应的服务器。这样，集群扩容时，可以将部分哈希值分配给新加入的机器并迁移对应的数据。 另一种思路就是采用一致性哈希（Distributed Hash Table,DHT）算法。算法思想如下：给系统中每个节点分配一个随机token，这些token构成一个哈希环。执行数据存放操作时，先计算Key（主键）的哈希值，然后存放到顺时针方向第一个大于或者等于该哈希值的token所在的节点。一致性哈希的优点在于节点加入/删除时只会影响到在哈希环中相邻的节点，而对其他节点没影响。 图3 一致性哈希 4.一致性协议 由于异常的存在，分布式存储系统设计时往往会将数据冗余存储多份，每一份称为一个副本（replica/copy）。这样，当某一个节点出现故障时，可以从其他副本上读到数据。可以这么认为，副本是分布式存储系统容错技术的唯一手段。由于多个副本的存在，如何保证副本之间的一致性是整个分布式系统的理论核心。 可以从两个角度理解一致性：第一个角度是用户，或者说是客户端，即客户端读写操作是否符合某种特性；第二个角度是存储系统，即存储系统的多个副本之间是否一致，更新的顺序是否相同，等等。 首先定义如下场景，这个场景包含三个组成部分： ●存储系统：存储系统可以理解为一个黑盒子，它为我们提供了可用性和持久性的保证。 ●客户端A：客户端A主要实现从存储系统write和read操作。 ●客户端B和客户端C：客户端B和C是独立于A，并且B和C也相互独立的，它们同时也实现对存储系统的write和read操作。 从客户端的角度来看，一致性包含如下三种情况： ●强一致性：假如A先写入了一个值到存储系统，存储系统保证后续A,B，C的读取操作都将返回最新值。当然，如果写入操作“超时”，那么成功或者失败都是可能的，客户端A不应该做任何假设。 ●弱一致性：假如A先写入了一个值到存储系统，存储系统不能保证后续A,B，C的读取操作是否能够读取到最新值。 ●最终一致性：最终一致性是弱一致性的一种特例。假如A首先写入一个值到存储系统，存储系统保证如果后续没有写操作更新同样的值，A，B，C的读取操作“最终”都会读取到A写入的最新值。“最终”一致性有一个“不一致窗口”的概念，它特指从A写入值，到后续A，B，C读取到最新值的这段时间。“不一致性窗口”的大小依赖于以下的几个因素：交互延迟，系统的负载，以及复制协议要求同步的副本数。 强一致性保证改动点之后，其它客户端都能看见修改的值。而最终一致性保证系统最终会让其它客户端都能看见修改的值，但是会有一个窗口，在这个窗口其它客户端会看见修改前的值。 5.负载均衡 分布式存储系统的每个集群中一般有一个总控节点，其他节点为工作节点，由总控节点根据全局负载信息进行整体调度。工作节点刚上线时，总控节点需要将数据迁移到该节点，另外，系统运行过程中也需要不断地执行迁移任务，将数据从负载较高的工作节点迁移到负载较低的工作节点。 工作节点通过心跳包（Heartbeat，定时发送）将节点负载相关的信息，如CPU，内存，磁盘，网络等资源使用率，读写次数及读写数据量等发送给主控节点。主控节点计算出工作节点的负载以及需要迁移的数据，生成迁移任务放入迁移队列中等待执行。需要注意的是，负载均衡操作需要控制节奏，比如一台全新的工作节点刚上线的时候，由于负载最低，如果主控节点将大量的数据同时迁移到这台新加入的机器，整个系统在新增机器的过程中服务能力会大幅下降。负载均衡操作需要做到比较平滑，一般来说，从新机器加入到集群负载达到比较均衡的状态需要较长一段时间，比如30分钟到一个小时。 负载均衡需要执行数据迁移操作。在分布式存储系统中往往会存储数据的多个副本，其中一个副本为主副本，其他副本为备副本，由主副本对外提供服务。迁移备副本不会对服务造成影响，迁移主副本也可以首先将数据的读写服务切换到其他备副本。整个迁移过程可以做到无缝，对用户完全透明。 假设数据分片D有两个副本D1和D2，分别存储在工作节点A1和A2，其中，D1为主副本，提供读写服务，D2为备副本。如果需要将D1从工作节点A1中迁移出去，大致的操作步骤如下： 1）将数据分片D的读写服务由工作节点A1切换到A2，D2变成主副本； 2）增加副本：选择某个节点，例如B节点，增加D的副本，即B节点从A2节点获取D的副本数据（D2）并与之保持同步； 3）删除工作节点A1上的D1副本。 注意：第二步，B节点是从A2获取副本数据，因为读写服务已经切换到A2，所以A2上面的数据是最全的。 思考一个问题：在A2提供服务时，怎么同时与B同步副本呢？ ​ 答：首先记录一个点，这个点之前的数据通过网络传输到B，然后这个点之后的数据通过操作日志的方法传输到B，然后在节点B上面通过操作日志+已经传输的数据 与A2保持同步。这样避免了A2一边进行读写，一边进行数据同步的任务而造成的性能问题。 6.复制 分布式存储系统中数据保存多个副本，一般来说，其中一个副本为主副本，其他副本为备副本，常见的做法是数据写入到主副本，由主副本确定操作的顺序并复制到其他副本。 如图4所示，客户端将写请求发送给主副本，主副本将写请求复制到其他备副本，常见的做法是同步操作日志（Commit Log）。主副本首先将操作日志同步到备副本，备副本回放操作日志，完成后通知主副本。接着，主副本修改本机，等到所有的操作都完成后再通知客户端写成功。图3-4中的复制协议要求主备同步成功才可以返回客户端写成功，这种协议称为强同步协议。强同步协议提供了强一致性，但是，如果备副本出现问题将阻塞写操作，系统可用性较差。 图4 主复备份协议 假设所有副本的个数为N，且N＞2，即备副本个数大于1。那么，实现强同步协议时，主副本可以将操作日志并发地发给所有备副本并等待回复，只要至少1个备副本返回成功就可以回复客户端操作成功。强同步的好处在于如果主副本出现故障，至少有1个备副本拥有完整的数据，分布式存储系统可以自动地将服务切换到最新的备副本而不用担心数据丢失的情况。 与强同步对应的复制方式是异步复制。在异步模式下，主副本不需要等待备副本的回应，只需要本地修改成功就可以告知客户端写操作成功。另外，主副本通过异步机制，比如单独的复制线程将客户端修改操作推送到其他副本。异步复制的好处在于系统可用性较好，但是一致性较差，如果主副本发生不可恢复故障，可能丢失最后一部分更新操作。 强同步复制和异步复制都是将主副本的数据以某种形式发送到其他副本，这种复制协议称为基于主副本的复制协议（Primary-based protocol）。这种方法要求在任何时刻只能有一个副本为主副本，由它来确定写操作之间的顺序。如果主副本出现故障，需要选举一个备副本成为新的主副本，这步操作称为选举，经典的选举协议为Paxos协议。这个后面进行介绍 主备副本之间的复制一般通过操作日志来实现。操作日志的原理很简单：为了利用好磁盘的顺序读写特性，将客户端的写操作先顺序写入到磁盘中，然后应用到内存中，由于内存是随机读写设备，可以很容易通过各种数据结构，比如B+树将数据有效地组织起来。当服务器宕机重启时，只需要回放操作日志就可以恢复内存状态。为了提高系统的并发能力，系统会积攒一定的操作日志再批量写入到磁盘中，这种技术一般称为成组提交。 如果每次服务器出现故障都需要回放所有的操作日志，效率是无法忍受的，检查点（checkpoint）正是为了解决这个问题。系统定期将内存状态以检查点文件的形式dump到磁盘中，并记录检查点时刻对应的操作日志回放点。检查点文件成功创建后，回放点之前的日志可以被垃圾回收，以后如果服务器出现故障，只需要回放检查点之后的操作日志。 强同步复制和异步复制的区别在于，客户端是否要等系统返回复制成功信息。 7.Paxos协议 8.参考资料 https://www.jianshu.com/p/2141a86452b1 "},"big_data/hdfs/":{"url":"big_data/hdfs/","title":"11. HDFS","keywords":"","body":""},"armory/":{"url":"armory/","title":"12. weapons 武器库","keywords":"","body":"军火库 "},"tech_framework/":{"url":"tech_framework/","title":"13.工程架构","keywords":"","body":"工程经验 1.修改原有接口时，要考虑对系统影响 "},"tech_experience/":{"url":"tech_experience/","title":"14.工程经验","keywords":"","body":"工程技巧 工程经验 "},"service_model/":{"url":"service_model/","title":"15.业务模型","keywords":"","body":""}}